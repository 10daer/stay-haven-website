 This section is all about getting data and then delivering it to our users in the best possible way by leveraging different techniques for data streaming, caching, and rendering. So we're gonna discuss and implement different approaches for content streaming with Suspense and a loading.js file. We'll also learn the difference between static and dynamic rendering and how and when we should use each of these strategies. Finally, we'll talk about how Next.js caches data and how we can use different caching mechanisms to improve website performance. So essentially, we're gonna dive really deep into how to work with data effectively in Next.js, which is, of course, extremely important, as data is the core of any website or web application. So let's waste no time and jump right back into our project and continue building. (bright music) Welcome back. So now it's time to get our hotel data into our website. And so let's now set up Supabase and connect the application to the Supabase database that we already have. So if you build the Wild Oasis app in part four of the course together with me, so before this part five, then you will already have Supabase set up and you'll have these four tables. Remember, so that's bookings, cabins, guests, and also some settings. Now if, for some reason, you skipped that big project, then please go back to the section called Supabase Crash Course, follow the videos there where I show you how to set all of this up and also how to get some data into these databases, like all of these bookings and most importantly, the cabins. And then once you're done doing all that, you can just come back here, all right? But in any case, from now on, I will assume that you have this data on Supabase, okay? And so what we have to do now is to, again, install the Supabase library in this project, just like we did in that other project so that we can read the data from the Supabase database here into our project. So right in our lib folder, which remember stands for library, and it is for JavaScript files that are related to our project but are not really components or anything like that. So let's call this one just supabase.js. And so now, as I just mentioned, we need to install the right package for that. So that's npm install @supabase/supabase.js. And now, we can create a Supabase variable here, which will then hold the result of creating a client. So let's call this one supabase and then createClient, which we just import from here. And well, for some reason, this used the require JS syntax, so that's not what we want. So let's just convert that. I'm not sure why that happened. From... Yeah, just like this. So here, we need to call this function and pass in our Supabase URL and the SUPABASE_KEY. Now this time around, we're actually gonna use something called environment variables to store this Supabase URL and the key because Next.js actually comes with built and support for environment variables. Now if you don't know what environment variables are, there are simply some variables that we can set up and that are available just to the Node.js environment in which the application is running. And we usually place them in a separate file and then Next.js will load that file and grab the variables from there and make them available on a special process variable. So that sounds a bit confusing. And so let's actually do this. So right here, outside of everything, we need to create a new file, which we call .env.local, and then here, we can just specify a few key value pairs. So let's call the first one SUPABASE_URL. And since these are basically constant, we use the convention of writing everything in uppercase with an underscore instead of a dash. All right, and so we grab that here from the project settings. So down here, in configuration and then API, we just grab this one right here and just paste that there. All right, and then back here, that URL is actually the first thing that we need to pass into createClient. And so as I mentioned earlier, that variable is now available in process.env., and then just the name that we created, so SUPABASE_URL. All right, and then the second one will be the SUPABASE_KEY. So let's set that up here as well. And so then here, we're going to need that key. Just place this placeholder here for now because I want to explain something else about these environment variables. So one key thing about them here, is that by default, they will not leak to the browser. So they're only really available inside this environment where the application is running. However, Next.js also allows us to make this public to the client. And all we need for that is to just prefix the variable with NEXT_PUBLIC_, more like this, and then here just some variable name. So this one here will basically leak to the client, so to the browser, while these ones that do not have NEXT_PUBLIC in front of them, are only available in this application again, so only here on the server basically. Which is really great because it allows us to place some sensitive, so some secret information here, without being worried that they might leak to the browser, which would enable some hacker or some other malicious actor to get access to them. And this brings us to a very important topic. So remember how in Supabase, we could just use this public key here, even on the front end without worrying that someone might do something to our database that we don't want. Because in order to protect our database, we would activate row level security, remember that? So again, we could simply use this public key here on our front end without worrying that someone might steal it. 'Cause even if they were able to steal it, they couldn't do anything with it because we had row level security enabled. And so then only the operations that we specifically allow would work. Now why am I actually telling you all this? Well, let's actually make this here big again and check out... I think it's here in the policies. So for example, in the cabins. Remember how we set a row level security policy here that only authenticated users have access to this cabin's data here, and the same thing for bookings and even for all of these. So again, only if the user was authenticated, only then they could access this data. However, that's not really helpful for us on this website, right? Because we actually want everyone to be able to see information on the cabins here without being authenticated, so without even having created an account and all that. So that should be public information right here, okay? And so basically we need a way of bypassing this row level security policy here because we do not want to remove it for our other application, so the one that we built in part four. So long story short, what we want to do here is to not use this public key, but instead, use this service row key, which as it says here, has the ability to bypass row level security. And again, that is completely fine because we can just store this secret key right here as an environment variable without ever worrying that it will leak to the client. All we have to do is to not do this right here, but really just placing that key here. And so then it will only stay on our server where it's secure, so where no one has access to. And so then we're just fetching the data from the client and then rendering those pages. And if we need the data on the client as well, as you already learned, we can just fetch it in a server component as well, and then pass it down to a client component as props. All right, so we're going to use this one here instead. So let's click on Reveal here, then Copy, and then you paste it right here. And so with this in place, we are now able to fetch and really do any operations on all of these tables right here. So bookings, cabins and so on, without any limitations. So basically whoever has this key has full access to all your data. So you need to be very, very careful with it and making sure that it doesn't leak to the client. And again, that's why we're storing it right here in this environment variable. And so let's use that here, process.env.SUPABASE_KEY. All right, and now all we need to do is to export this from here, and then we're done. So let's close this and let's go back to our lib folder where we then have this data service file. And so this is where we need that SUPABASE_KEY. And so let's just import, not the SUPABASE_KEY, but the Supabase client. So as I mentioned earlier, here, I already pre-wrote all of these functions here, and they are pretty similar to the functions, once again, that we already wrote in the first project that we did with this data in part four of the course. And so there's really no need to write all that again. So import supabase. Well, that's not what we want. Yeah, this is the one, all right? And so from now on, this file should work and we should now be able to fetch cabins and all of this other stuff here and even perform some mutations like creating guests or creating bookings, which will all be doing throughout the rest of this course, all right? So now we have Supabase nicely set up and are ready to start working with this data in the next video. So with our new ability of fetching data from our database now, let's begin by building the cabin list. So that overview of all the existing cabins should live here in this page at slash cabins. So that's this one right here. And notice how right now all we have is the cabins variable with this MT array. But of course now it's time to change that and actually fetch the real cabins here. And for that, we already have a function in the data services. So these functions that I have pre-written. And so it's this getCabin's file right here. So this will get the ID name, max capacity and so on. And we'll order them by their name and then return them right here. And so let's fetch some data right here in the server components. So remember how here we can now use async await to fetch data. So let's make this an async function, and then all we have to do here is to await the getCabins function, and that should be it. So if I save this now, then S React renders this component. It will basically wait right here. So execution is stopped like in any regular async await function. So it stopped right here, and then only after this data has arrived, then this part here will get rendered. So this will become an array, which will then get rendered out here using one cabin cart component for each of the cabins. It's also logged this here maybe to the console cabins. And let's maybe also log to the console like starting just so we see what I just mentioned. All right, and there we go. Now the styling is a bit off here because of these images, but we'll see about that later. What matters is that here in the output. So this component starts rendering, and so then this starting here is locked to the console. Then this data is fetched. And so execution here pauses basically, and then the cabins data is locked to the console right here. Beautiful. So again, this might look pretty crazy for you if you're not yet used to React server components, but this is really great. So we don't need any use effect here. We don't need state to store that data into. And we don't even need any separate data fetching libraries. All we do is await the data fetching function right here in an async function. And all of this happens, of course, right on the server. And then the already rendered HTML is what will be sent to the browser. Now remember how I said in probably the first section where we talked about React server components, that one of the great thing about this pattern is that we are really close to the data source right here on the server, and many times don't even need the API layer. Now in this case, since we're using an external service, which relies on an API, we actually do still have an API layer here. It's just hidden from us because these supabase functions here, they abstract the API away from us, but we're still grabbing the data right here behind the scenes from the supabase API. But if we were using some other solution, for example, like (indistinct) key value data storage, there we could actually read the data directly right here in the components without using any API layer, right? So just wanted to bring all these points that we talked about together here. But anyway, this is now working beautifully. And once again, if we check out the source here, we can see once again that this actually really happened on the server. So all of this stuff here is exactly what we are rendering on the server during the initial server side rendering. So right on that initial load. Okay? But now let's check out the cabin card component to fix those images. Yeah, because here as we get this warning, we should use again Next.js's image component and also import that here at the top from next image. But that alone will of course not fix the styling. Quite the contrary, we actually get a new error here. And so again, that's because we're missing the required with property, which is mandatory when we are loading the image from a string, which is now actually the case. So that's one of the cases that I mentioned to you in one of the image lectures that we had in the previous section. So when we want to load an image directly from a URL, we either have to specify the height or width, or we need to use the fill property. And so then we get into that territory where we have to use that additional trick to make the image responsive. So that's what we did in one of the lectures in the previous section. And so let's just quickly do that here again. So here we need to specify fill, but then the images will probably fill the entire viewport. But before we can go fix that, we actually have another important arrow, which is a very important one. So this brings us to an important point, which is that whenever we want to optimize an image using the Next.js image component, and that image is hosted somewhere else, so in this case here on supabase, we need to actually add that path here to our Next.js config and to check out how we can do that, let's actually open up this right here. All right, so let's copy that code here. That's a bit easier than writing all of this by hand. And so this is where we now need this Next.js config. So right here is where we paste that, but now of course we don't want this, but instead what it tells us to use here. So this host name, so basically that's this first part of the image right here. So let's copy that, paste that here. Then the port, we don't need to specify. And then for the path name, we need then this other part right here. So all the way here without the file name itself. And then in the end, we will actually leave these two stars. So this pattern right here, which basically tells Next.js that any images in here work. So if we reload this now, then this should fix the error and it should then work. Now there's still some error in the console, so now there's some problem in the layout for some reason. Well, that's very strange. Let's reload again and we get the same error again. Well, let's see. Ah, okay, yeah, here, we actually do not need that part. So the HTTP is already there in the protocol. So now we should get it right. So let's wait for that again. So this is always a little bit tricky, but here we go. So now all the images are here, but as I mentioned earlier, this fill here now makes it so that it does fill the entire view port because we don't have any parent element that has the position attribute set to something, right? And so now we will use that trick that I mentioned earlier, and also in the previous section where we used this one here as the parent, and give this one here a size. So in this case, we allow this to grow, this flex item to grow because the parent is a flex container. So this is a flex item. And then here we just have this one here, fit dead parent. So with object fit set to cover. So again, that's object dash cover with Tailwind. So let's wait. But we still are missing that relative that I mentioned earlier. So we need to set position to relative, right? And so that, yeah, that fixes it. Beautiful. And so with this, the images are optimized. Again, they're nicely styled and they should be responsive as well. So you see as these diffs here get smaller, the image will just try to fit there, but without being distorted. So we'll just again, cover that diff. And if we make it bigger, then it starts looking even better. Okay. And yeah, that's almost it. Now the only thing we need to do is to fix that link, which is again, an aid and anchor, but we want it to be a link. So let's import that as well. Link from link. So if we click there, it'll then take us to the detail cabin page, which will change the URL there. So let's actually check that out. So what it does is to dynamically build the href with cabins and then slash the ID of the cabin. But we're gonna be worrying about that a bit later. So of course, now this tells us that the page could not be found because this URL here. So this route does not exist in our file system. We don't have any route or any page for that. But again, we're going to be implementing that later. Let's now go back to the loading.js convention file and implement a more specific one only for this cabins route. So notice what happens when we reload this page, or maybe we can even reload the page right here. And then as we click here on cabins, notice that here we get this loading data indicator, right? So that comes from the loading.js file that we set up in the first section. So that's this one right here. And since we're already here, let's actually make it a bit nicer by using a spinner. So that is also here in the starter files. So we have Spinner and SpinnerMini, which we're gonna need a bit later. So let's just grab both of them since we're already here. And so here, let's simply render that spinner actually. So just gonna grab that spinner like this and then return it immediately. Okay, well, I want to use again the @ convention here. And so now let's see what it looks like. Yeah, so that's a bit better. So we get that loading spinner right there. And that is actually good enough in theory, but I want to show you something else. So I want to show you how we can have this one like global loading indicator with this loading.js, but then also having one more specific one only for specific routes. So how do you think we can do that? Well, maybe you can guess it. And the way we do it is just like with all these other convention files. So the way this works is that we create another loading.js, but close to the route on which we want to actually show it. So in this case, since we want a different one here for the cabins route, we create that loading.js right here. So inside the cabins page, which again, is responsible for the cabins route. And so then this loading.js will apply to this cabins route right here. And also all the sub routes. So just like this loading.js here also applies to all subroutes. For example, this account/profile or account/reservations. Since we don't have any other more specific loading.js here, then the global one will still apply. All right, but if there is one, like now here in cabins.js, well, then this one is gonna be the one that's shown. So let's do again export default function Loading. And well, actually, let's just grab the code from here 'cause we still want to use a spinner. Now, right, but let's then just write some more specific text below it. So let's place this here inside a div. And so here, let's then just add some quick styling. So let's make this a grid items-center and justify-center. So to basically center everything in the container, so vertically and horizontally. So this is a nice trick to do that. So it aligns items-center and justify content center on a grid container. So then in there we just place a spinner. And let's do a paragraph which says loading cabin data. And so then again, with this cabin word right here, that means that it's really specific to this page. Just make this text a bit bigger and give it also the primary-200 color. All right, and if we reload now, then beautiful. You saw that there. So it said loading cabin data there. Well, we don't have any other page where we could now see the other one. But trust me, on all the other routes, we would now still get the original loader. So this one right here, okay? And it's important to remember that having a loading.js file will activate streaming. And this was already activated before because we already had one loading.js file, right? But in any case, just remember that this means that streaming is activated, which will require JavaScript to be enabled in the browser. So this website will now no longer work without JavaScript activated right here. And we can actually test that I believe while we're here in the console. We can hit Command + Shift + P or Control + Shift + P. And if we then write JavaScript here, yeah, then we get this icon here that JavaScript has been disabled and so now this should not work. Yeah, so now just it just renders loading cabin data in the beginning, but then nothing's gonna happen. Okay, but now let's... Well, let's allow that again. Well, that didn't really work. So let's do just the same as before. So hitting Command + Shift + P or Control + Shift + P on Windows probably. And here we are again. Great. Now let's just do this one more time so we can notice something here. Saw that? We couldn't see any of the content, even though only this data right here was actually fetched from the Supabase API. So this data right here, so basically this text and this heading here, they don't have anything to do with data fetching. And so actually if we think about it, they could already be rendered like initially, and we could have then the loading spinner only for these cabins here. So only for the data that is actually being fetched. So essentially what we want is more granular control over where we render the loading indicator. Now, for doing that, it becomes a bit more complex because we need a feature called suspense, which is a React feature that I might have mentioned a few times already, but we don't really know what suspense is and how it works. And so before we go use suspense, let's first learn what it actually is in the next video. So let's now talk about a modern React feature called Suspense. Now, I've mentioned Suspense a few times in this course already, but now it's time to actually understand what Suspense is and how it works. So Suspense is a built-in React component that we can use to catch or to isolate components that are not ready to be rendered yet because they're doing some asynchronous work. And we say that these components or even entire sub trees are suspending. Again, because they're not yet ready to be rendered by React. So conceptually, we can think of Suspense as being like a catch block in a try-catch statement. But instead of catching errors, it catches components that are suspending. Now the important question here is what might actually cause a component to be suspending in the first place? Well, there are two main reasons, which are both asynchronous tasks. The first one is fetching data using a library that supports Suspense, and second loading additional code using React's lazy loading feature, which we've actually already used earlier in the course. Now the main use case of Suspense is indeed data fetching. And so let's look at an example of that. Just note how I mentioned that we need to use a data fetching library that actually supports Suspense. For example, React Query, or also Next.js, but more about that in the next slide. So anyway, let's say that we have this component tree for an e-commerce app in Next.js where this products component will fetch some data. So this is our component that will be suspending while it fetches the product data. And since we now have a suspending component, we need to catch it using Suspense, right? And so what we do is to wrap this sub tree into a Suspense component that we can just import from React. Now, we could also only wrap the products component itself, but let's say that filter depends on products in order to work. And so we keep them together here under the Suspense component. And with this, we just implemented a React native way to support and handle asynchronous operations like data fetching in a declarative way. And as always, declarative means that we can use components in our JSX instead of imperative render logic. In this case, all we have to do is to just wrap a component that an asynchronous operation into a Suspense. So we'll no longer need isLoading states and ternaries in our render logic, which will make our components so much simpler and especially (chuckles) so much cleaner. Now okay, so that's what Suspense is. But what actually happens when we use it like this? Well, whenever during the render process, React finds a component or a sub tree that is currently suspending, it'll move back up to the closest Suspense parent, which we also like to call a Suspense boundary. It's a boundary because it separates the suspending sub tree from the rest of the app. Now at this point, React might already have rendered the filter component that doesn't depend on products. However, in this step, all the already rendered children are simply discarded and a fallback component or piece of JSX is rendered instead. While the asynchronous operation is happening in the background. And usually, that fallback is just a loading spinner like we see here and that we have used many times previously. The difference again is that previously we had to use an isLoading state and then render the spinner inside products whenever isLoading was true, but in this scenario with Suspense, we can render the spinner instead of the product component whenever product is suspending, making that component a lot more declarative and also giving it fewer responsibilities. Now, once the async work is done, or in other words, once the suspended component is ready and no longer suspending, React will attempt to render the sub tree under the Suspense boundary. Again now, with the fetched product data. And so that's how we use Suspense. Now, it's very important to note that components do not automatically suspend just because an async operation is happening inside of them. So again, if we just make a regular fetch request inside an effect or an event handler in a component an a regular React app, the component will not automatically suspend and Suspense won't work as I just described. The whole Suspense architecture is extremely complex and manually integrating asynchronous operations with Suspense is very hard. And so we leave this work to libraries and frameworks, just as I mentioned in the previous slide. Now, thankfully for us Suspense works out of the box if we use something like React Query, remix, or of course Next.js. Also, Suspense works just as advertised when combined with React.lazy, such as we did earlier in the course. Okay now, if you just wanted to understand how to use Suspense, you can actually stop the video right here. But if you do want to understand a few additional details, let's take a brief look behind the scenes. Nothing too crazy here, but just to make sure that we understand the whole picture. So let's bring back our tree, but this time it's actually represented as the fiber tree where child and sibling relations are implemented in a slightly different way. And in case you didn't watch the section on how React works behind the scenes, the fiber tree is basically an internal representation of each component instance and DOM element of our app. The difference between this tree and the component tree, so basically the virtual DOM, is that the fiber tree is a mutable data structure that is never destroyed, which makes it the perfect place to store state, hooks that were used and so on. It's also this fiber tree that enables so-called concurrent features, which allow React to pause rendering with Suspense in the first place. Now, behind the scenes in the reconciliation phase, whenever we use Suspense, the child tree below the Suspense boundary is actually moved into another built-in component called activity. And again, this happens in the fiber tree. So you won't actually ever see activity in the component tree if you check it out using the React DevTools, for example. So you won't ever use this activity component directly in your code. On top of that, the fallback that we specify is also already placed in the fiber tree as a sibling of the activity. Now that fallback is initially hidden because a so-called mode on activity is set to visible. Meaning that the Suspense children are now visible. Then as soon as the component Suspense, this mode will be set to hidden, and as a consequence, the fallback spinner will be rendered and the sub tree will be hidden. Now, once the asynchronous work is done, the activity mode gets set back to visible and the final sub tree can finally be rendered. Now, if a component suspends again later, the fallback will be shown again, and this entire process runs again as well, always keeping the sub tree in the fiber tree. Now, in the previous slide, I mentioned that the rendered work is discarded, which is actually true, but here we're looking at the fiber tree where elements are actually not destroyed, and this has a very important implication. So the fact that the Suspense children are simply hidden and remain in the fiber tree means that all state in the sub tree is preserved during subsequent suspending and unsuspending phases, which is something really, really important. Okay, so I hope we are clear so far, but we still need to continue (chuckles) a little bit. Now, there's actually one exception to the rule that the fallback will be rendered again if the component Suspense again. So the fallback will not be shown if the function that triggered the Suspense, for example, a fetch call is wrapped in a transition using Reacts startTransition function. And we'll talk more about transitions later, but why does this actually matter? Well, it matters a lot because in Next.js all page navigations are wrapped inside transitions. This means that, for example, if a component re-fetches data as a result of a page transition, or in other words of a navigation caused by the user, the fallback will not be rendered again, which can seem pretty strange and many times is actually not what we want. But luckily for us, we can actually easily fix this by passing in a unique key prop. So similar to the key prop that we have learned about earlier. And so this will then reset this Suspense boundary. And I know (chuckles) that all this sounds pretty confusing, but don't worry, we'll do this of course in practice later. Here I just wanted to explain this strange behavior step by step. Alright, and now just to finish, one final and very interesting question that you might have is how does the Suspense boundary actually know that a child component is currently suspending? I mean, it's a child component, and usually children don't talk to their parent components in React, right? So how can this work? Well, the trick is that behind the scenes a component throws a promise, which will then trigger the Suspense boundary to render the fallback. So this is a bit strange because usually we throw errors and (chuckles) not promises, but this is the mechanism that the React team came up with. Again, the whole mechanism behind this is very tricky, which is why this needs to be integrated into a library like React Query or Next.js. But on a high level, a component marks itself as suspending simply by throwing a promise and thereby notifying the closest Suspense boundary. And there you have it. So this is how we use Suspense and how it works behind the scenes. But enough talking, (chuckles) let's now finally get to using it in practice. So now that we know what Suspense is in React, let's use it in order to stream a single piece of the UI and in particular the list of cabins that we have been working with. Now, as we learned previously, we can use a loading.js file in order to implement streaming and show a loading indicator for an entire route segment. And so that's exactly what we did two lectures ago. So we implemented this loading indicator right here, but that indicator blocks basically the entire page. So the entire UI. So I say blocking because this part right here doesn't depend on the data at all. So this text, this heading, and this paragraph, they could be loaded in immediately, and only this part right here, so that cabin list, which depends on the data, would need to be streamed in. Again, not the entire page because this part right here doesn't depend on the data at all. And so instead, we should actually have a more granular strategy of streaming data. So again, streaming the cabin data only for this list itself. And so in Next.js, we can use a Suspense boundary in order to achieve that. All we have to do is to move all the data fetching into its own component and then wrap that component into a Suspense boundary, just in the way that we learned in the previous video. All right, so let's do that. So what we're gonna do is to wrap all of this here into its own component. So let's create that here and call it the cabin list. So CabinList.js. And here let's actually use that snippet that I showed you earlier, which is RFC, which simply creates a new React component. And so let's close this one here. And so all I'm gonna do is to grab this code right here, place that in here, and then we need to of course grab this CabinCard, but also we will want the data fetching itself. So let's get these two. Actually we can remove the Counter from here as well. So just doing some refactoring. And now finally, as I mentioned, let's remove this from here. So we can use a sync await not only on a page of course, but really in any other server component as well. And so this is of course also a server component 'cause it doesn't use the use client directive at the top. And so we can just do this. All we have to do is to also make this an async function. And so this should now work perfectly fine. All we have to do is to place that in here. So the CabinList. All right. And yeah, of course this part here also needs to be in the other component. So we have no way of knowing the length here. So let's go there. And actually here, let's just say if null cabins.length return null, so that would be a bit cleaner. And so now we did all the refactoring that we needed. So again, since these two here do not depend on the data at all, we just moved the data fetching into its own component, which is in Next.js always a good thing to do. So we should get used to always have the data fetching as close as possible to the place that actually needs that data, because by doing so, we can then implement a more granular data fetching strategy. So which is what we're about to do. So for now, actually all that we did was refactoring the code, but everything here will work the same. So for now, we will still see this loading screen right here 'cause we didn't use Suspense yet, right? So that's what I just said. So for now, we still have like the blocking UI where everything is streamed in at once, but now we're done with this one. And so let's use that Suspense that we want to use. So what is the whole goal of this lecture. So that is Suspense into import that from React, and then we wrap that CabinList inside the Suspense. So just making sure it has been correctly imported from React. And now this Suspense takes in a prop for that fallback. And here we need to specify a piece of JSX. So let's use the Spinner here. And we cannot just pass in the Spinner, so we cannot do this, but it really needs to be a React element. So basically we need to call the Spinner here. And now as I saved this, what is going to happen there? So you saw that the Spinner was only right here. And just to see this a bit better, I actually have some piece of code here that will slow down the data fetching. It's actually here. Let's grab that just so we see that Spinner for a bit longer. Do that here, for example. So let's do two seconds. And so if we reload now, then we will see this Spinner for two seconds. And so again, only right here where the list will then be rendered later while this piece of the UI can be shown immediately. All right, let's just turn this off again. And so this loading.js file that we have here right now has basically been overwritten and replaced by this Suspense boundary right here. Now all right. So I believe this creates a much better UI or actually a better UX. So better user experience for our users. I mean, in this case, it doesn't make a lot of a difference also because this data here is pretty fast to come in. But this is all to show you these different possibilities that we have, all right? So let's recap what we did here. So we basically have two options when it comes to streaming and showing loading indicators. We have a more global one, which will stream in and replace the entire page, which is what we do with a loading.js file like this one. So that was our initial approach, but that again can create a blocking UI. And in some cases that's more than enough. For example, if we didn't have this text here and all we had was this list that fetches some data, then in that case we wouldn't have to do anything like this because there wouldn't be any other UI to be blocked. And so then just the loading.js file would be enough. So that's the first option. But the second option is to be a bit more granular in our streaming approach and having only a certain component which fetches data to be streamed in and therefore to be replaced initially by a loading indicator. And that's exactly what we did here. And in order to achieve that, we needed to first move the data loading into its own component because there is of course no way of wrapping this entire page into a Suspense. So initially we had the data fetching here, but it is not enough or it doesn't work at all to then like wrap the entire JSX into a Suspense. So having the Suspense like here for example. No, the Suspense needs to be outside the component that does the asynchronous work. And so that's why we moved that asynchronous work into this component of CabinList and then placed the Suspense outside of that. So we wrapped the asynchronous component that will suspend at some point into the Suspense. And so again, it is this component here, who now does the data fetching, and then as soon as it's ready, it will render out these CabinCards. Now you don't always have to go for this approach. So as I mentioned, if all you have on a page is data loading, then you don't have to do this. But in general, if you want a better UX for your users, then it is a good idea to keep the data fetching as close to the components, or even inside the component itself that actually needs the data. So this is always the best practice in Next.js that you should follow in your own applications. Alright, and we will practice this more as we go through the rest of the course. I just noticed or remembered that here we can get rid of the async now because this is indeed no longer an asynchronous component. Okay? So please make sure to understand what we just did here. Maybe try to experiment around a little bit with this code. And then once you're done doing that, we will actually start implementing these cabin detail pages that appear once we click on one of these links. So let's now finally build the individual cabin pages. And in order to be able to do that, we need to learn about something called dynamic route segments. So basically, whenever we click on one of these links here, it should take us to the individual cabin page. And so the URL that we built for that, is like this. So cabins slash and then the ID of the cabin. So 91 here, but if we click on this one, then we have 89, or this one here, for example, 90. So how can we do this? Because first of all, of course we do not know these IDs here in advance. And even if we knew, if we had like 20 IDs, then we are not going to create like 20 folders in here as a child route of cabins, right? That wouldn't make any sense. So we are in a situation where we don't know this segment here of the URL in advance. And so this is when we need to use dynamic route segments. And it's called dynamic because really this value here can be anything. It is not predetermined. Instead, this dynamic part here of the route is gonna be filled at request time, or it can also be pre-rendered. But that's for later. All right, so let me now show you how we can implement a dynamic segment. So first of all, it is of course a child segment, so a child route of cabins. And so it needs to be once again a folder inside cabins. So the way we do this is that we use square brackets. And then here, we will use the name that we want to give this part of the URL. So this here is the ID of the cabin. And so let's call this the cabin ID. Then close the square brackets. And well, I think I created a file-der, (chuckles) file accidentally. Not a folder, also not a file-der. Now, okay, so now we have this folder right here, which is a new route. And then as always, in there we need a Page.js. Which doesn't export anything. So we should get like an error here. Or well, still that 404. And so let's now grab the code here from cabin page. So just this one here. So here we actually have some placeholder data because otherwise we would get some errors. So let's actually grab everything here and then paste that here. So let's see what we have. We have a few icons. And then basically, we include a bunch of different variables here, which we're grabbing from this cabin object. Which is for now this placeholder. So in the beginning, this will be exactly the same page for all of them, but of course what we're gonna do then is to load in this data dynamically. So let's just save this, and here we go. Now we don't have the correct styling here yet. Once again, but let's worry about that later. Okay, so what matters now is that we can click on any of these links, and then we will get taken to this page. But as I was saying, of course, we do not want to use this placeholder data, but instead, fetch the actual cabin data. So for that, we again have a pre-written function here in data service. And so here, what we want is this get cabin function right here. Now of course, this will need the cabin ID of the cabin that we want to fetch, right? And so, we need the way of actually getting that ID. So let's actually start with that first. So the way this works is that any page, or even a layout for that matter, that is associated with a dynamic route segment, which is clearly the case in this page, gets access to a params argument. Or actually, a params prop. So we need to structure this as if it was a prop. And so, here we get this params. Well, let's log this to the console. Params like this. I'm not sure what's happening here, but this is from way back apparently. Let's go all the way down here. And immediately we get here, this params logged to the console. And so, what we see is that here we get this cabin ID, which is exactly the name that we gave to this folder. So name that we gave to this dynamic route segment. So here it was called just ID for example, or CID. Then that would be the name here in this object. All right, and so now it's very simple, we just need to use that to get the single cabin. So cabin, and so this now needs to become, again, an a-sync function. And then here we can just use 'await' in this nice server component. So hopefully, you're starting to get used to be able to use this nice syntax of a sync await in a regular React Component. Okay, and now here, again, we need to pass in D, ID, which we simply get from params dot cabin ID. No longer need this. And we can also get rid of this placeholder data, give it a safe. And now here we should get the cabin associated with the ID of 91. And there it is. Beautiful, so let's go back here. Let's click on four. And notice how we had that loading indicator there again. And if you look closely, so let's do that again, you will notice that it has also that text. And so that's exactly this loading indicator right here with the loading cabin data. Let's check that again. And there it is, right? And so, as I mentioned before, the reason for that is that this Loading.js file will apply to the current route segment. So that's cabin plus all of the child segments. So all the child routes as well. As long as they do not have their own Loading.js. So of course if we wanted, we could create yet another one in here. And so then that's the one that would be applied. But in this case, it actually makes sense to have this one. So, which says loading cabin data, because that's actually quite correct here. Now just one more thing, if we go again to one of the pages that we already went to, maybe we didn't go to this one. So let's go to cabin five again. Well, actually I thought that we would see some caching going on here, but I guess since we're in development mode, that doesn't really work. But that also doesn't really matter here right now. We're gonna talk more about caching later on. For now, let's just fix this image right here, using again, the built-in image component that for some reason, Next.js or VS code here doesn't automatically import for us. And so yeah, now we will get exactly the same problem as before where we do need to specify the height, or we can just use fill. And if we use fill, then remember that we need to do that whole technique with object cover. So that's why we already have here this parent dev with the relative class. So since we had already done this multiple times, here, we don't need to do the whole thing again and again. Okay, so that looks really nice, really cool design, I think. And yeah, I hope you feel the same. So if you ever add this to your portfolio, maybe then I'm sure this will look really, really great there. So just check if it works for all of them. Yeah, beautiful. And so that's actually all we had to learn in this lecture. So just as a quick recap, basically each of these pages here has its own ID. And so this part here is unknown at runtime. And so therefore we need to use a dynamic segment, which works for every possible case. And so that's why we use the square brackets convention here. And then this name that we give the folder here. So that's the name of the dynamic route, cabin ID. Then in the page that's associated to that, that value is read from the URL here and placed into params dot cabin ID. And so that's how we can then fetch the data specific for this page. And we did something similar earlier when we used React Router. So when we did a client-rendered application as well. But there of course, it worked a little bit different. Because here it's all about conventions. And so here you need to learn that this is how it works. But I think it's pretty straightforward, and you're gonna need this all the time. Let's fix a problem that we currently have with the Titles of our Individual Cabin Pages by generating metadata dynamically. So notice how, once again, we have the Title here now, set to Welcome, which remember is the default. So if we go back here, then we have Cabins. But in any of these pages, we then go back to the default of Welcome. So we should fix that. And a first valid attempt would be, once again, to export the metadata, just like before, setting a Title. And let's say, "Cabin" just like this. But this is still not ideal. So ideally we would also want the name of the Cabin like 004, up here in the Title. But how do we get that data here? Well, that's where that part that I said in the beginning comes into play. So generating metadata dynamically. So instead of exporting this variable called metadata, we can also export a function called, generateMetadata. So one more convention right there. So let me show you how that works. So this is gonna be an async function. Because here we are going to fetch basically, the name of the page so that we can then place it there in the Title. So again, export async function, and it needs to be called, generateMetadata. Now this function also gets access to the current params. So just like the page. And so then in here we can grab the name of this cabin. So let's just do exactly what we did here. So fetching this same data, and then let's immediately destructure and get the name. So we have the name now. And so all we have to do is to now return here an object with a similar shape of what we had before up here in the metadata. So we just return an object again with Title, and then here we can just do it like this. So Cabin and then with the name. So we give it a Save and beautiful. So there's our Cabin 004. Now next JS will wait for this data fetching here inside the generateMetadata function to complete before streaming the UI to the client. And so with this, we can always guarantee that the first part of the response that is streamed includes correct head text. Okay, and so if we go back to another one, then it takes a little bit here. So it shows that like ugly Title that we also saw previously. But as I mentioned earlier, there is really no way around that. I really hope the next JS fixes this at some point, because it can look pretty ugly. But again, we now get exactly that name up there. Nice, and that's actually all I had to tell you here in this lecture. Next up, we're gonna move on to some simple error handling. So now that our website is working, for the most part, at least when it comes to rendering some data about cabins or about the hotel itself, let's turn our attention to some simple error handling and in particular, to setting up a global error boundary. So let's say that we manually attempt to go to some URL with an ID that doesn't exist. So that might happen, for example, if we change all of the URLs, or all of the IDs of the cabins, but some user then still has, for example, this old URL bookmarked and then they go here, and then they will be greeted with this error. Because this cabin here does of course not exist with this ID, so this becomes null and then we cannot destructure. So we get actually an error right here in the generate metadata function. But if not here, then we would also get it somewhere else. Now, this one is actually more of a Not Found error, which we're gonna deal with later. So let's maybe generate another error here. So this is one type of error that we could see, but there could also be something simpler. For example, let's say that for some reason, the developer thinks that here we don't have max capacity, but instead that capacity is an object like this. And then on there we just read the max property. Well, don't know why that changed back. So let's say that we have this. So this of course will then create an error because capacity.max doesn't exist, and so then we cannot read the max property from there. Now of course this error would be caught immediately during development, but some bug like this could make it into another part of our application and could not be found by us. And so then maybe at some point, the user of our app would get a screen like this, which looks really bad. I mean, this actually only appears in development. So in production, the error screen would look different, but still, it wouldn't be what we want to show the user. And so instead what we want is to set up a global error boundary. And so that will then automatically wrap the entire application into a React error boundary. So very similar to the error boundary that we actually set up manually in another app earlier in the course. But here, everything is gonna happen kind of automatically. All we have to do is to use yet another convention file, called Error.js. So let's create that here again in the root app folder. Error.js. Now, right, now, of course you don't have anything here, but I actually already have something here in the starter files. So yeah, let's actually grab all of this code here. Could even have used the entire file. But anyway, let's do it like this. And now one important thing to note about this is that the error boundary actually needs to always be a client component. So we need to place the use client direct to here because this error component here, which again could be named anything, but error makes sense here. So this will get the error object itself, plus a function that we can call to reset the error boundary. And so that clicking, so that action basically, is something interactive, which can only happen in a client component. So let's accept these two things, error and reset. And if we reload now, then let's see, yeah, let's just reload once again manually here. And so then we get Something Went Wrong. Now, right, now here we didn't have this error. And so let's replace that with the actual error message. So error.message. So capacity is not defined. That's a bit better, at least for us developers. Then here on this button, we can simply specify the onClick handler, which will then call the reset function. This is more gonna be like a reload, which in this case doesn't do anything, but in other situations it might. You can copy paste this error boundary that we just created here and place it into any Next.js applications that you're gonna build in the future. So again, clicking here is not gonna do much. Maybe we should rather redirect the user back to the homepage here, but well, nevermind. Let's just leave it like this. Here, the user can always go back manually. What matters is that we have a nice error message that is embedded here in our own website, and has the same styling as the rest of the page. Now, as with all these other files like layout.js or loading.js, we could also have multiple error boundaries, even deeper here in our structure. So basically, having nested error boundaries. And then of course the closest one would be shown. But in a simple application like this, that's not necessary at all. Just keep in mind something that I think I mentioned when we manually set up an error boundary earlier is that this works for all errors and exceptions that happen anywhere in the app, but only in rendering. So any errors that will happen in callback functions will actually not be caught by a React error boundary. All right? So something to keep in mind. So only rendering errors will be caught right here. Another important thing, and just to finish here, is that this Error.js boundary does not catch errors that might happen in the root layout. So in this root layout that we have here. So in this layout we might, for example, also be fetching data, which is something perfectly fine, which we could do. There's nothing stopping us from doing that, because this is just another server component. But if that data fetching would create some error, then our error boundary would not catch that. If we still wanted to catch any errors, even if they are in the root layout, then we would need to create a file called global-error.js. And so that will then actually replace the entire layout. So even the root layout will then be gone. So the idea behind that is pretty similar, but the global error also needs to define its own HTML and body text, just like the root layout, because again, these will then be gone, and so therefore then we need to place them in that global-error.js. But in this case, we really don't need that. And so there's no need for creating that file right here. And as always, if you want to know more about this, you can just go check out the documentation for all these conventions. I think there's actually one page which contains really all of that. I'm not sure if that is this page right here. Yeah, but it actually is. So this project structure here contains all the different files that we can create. So all the routing conventions like, so here it is, global error or just error. And here you see that we have some other ones that we're not even going to use, like default, template, route. And yeah, so here is that dynamic route segment that we learned about earlier. And we can even go more crazy with that like this. And yeah, you can check out all this if you want, but for now we're just gonna move on to the next lecture, which is another one about error handling, in which we're gonna talk about these Not Found errors. Basically something like this. So let's see what we got here. Yeah, so that error that we also saw earlier, but here in this case, it makes more sense to display that This Page Was Not Found. And so let me show you how to do that right in the next lecture. All right, welcome back. And now let's talk about how we can handle not found errors and even actually manually creating them. So let's go. So in the previous video, I briefly mentioned that this error right here should be more of a no found error, but actually let's not start with this one, but with the more common not found error, which is if the user tries to go to some route, which we never even defined like this, so then Next.js will automatically give us this 404 error saying that the page could not be found. And once again, we do maybe not want this default error that's coming from Next.js, but our own one. So it looks more according to our own style. And so yet another convention for that is the not, well, that's not working, so not-found.js. All right, so here, as always, we need to export something. And I already have the code right here. Let's just grab that. Place that here. Here it should be a link. And then we just import that as always from next/link. And now, like magic, our own error will appear here. So this page could not be found, beautiful. So that's already way better than before. Then we just click there and can go back. Okay, but now back to that other error that we had previously. And first of all, let's of course get rid of that error that we have here we added manually. Nice, but now let's go back to this where we go to some cabin here, so basically to an ID that doesn't exist. And so this is where I said that this here is also more of a no found error, because really what's happening here is that this cabin with this ID doesn't exist. So then basically we also want to display that this page could not be found. So basically something similar to this one right here. So how could we do that? Well, in Next.js, the not found page can actually be shown in two ways. First, an automatic way, simply if the URL doesn't exist, so what I showed you a bit earlier. And second, we can also manually basically trigger this page by calling the notFound function. And so that's what we're going to do here in this case. So let's go to where we fetch the data. So right here getCabin. And so here, let's actually say that if there is an error, we don't want to do this, or maybe we can also log it to the console. But really what we want is to call manually that notFound function, actually with a lower case here. And then we need to import that from Next.js. So this is yet another API that is provided to us by Next.js. So, again, the notFound function we just call it here. And first we need to import that. import notFound from next and this time /navigation. Okay, give that a save. Let's reload here. And now we get an error that this is not a function. So I guess this is a named export then. Let's retry that, and beautiful. So now we get what we wanted. This page cannot be found. So I think that is a lot better error message here in this situation. Now, to take this one step further, we can create a more personalized error message here only for the cabins. So how do you think we're gonna do that? Well, as you might have guessed, we're just going to create another NotFound, but right here inside this cabinId folder. So basically a not found error that only works on this route. So just like we can do with all the other ones, so with the loading, with the layout and so on. So just pasting that here. And so here, let's say, "This cabin can not be found," and then here back to all cabins and changing the href here to /cabins. And so that looks even better. All right, and with this, we actually finish kind of the first part of the section, which was about data fetching and data streaming. And so next up we're gonna enter the topic of data rendering, which is another pretty important thing in Next.js and in web development in general. And so I can't wait to see you there in the next video soon.

 All right, so now it's time to learn about the two types of server side rendering that exist in Next.js, static and dynamic rendering. And let's start with a quick overview of how rendering happens on the server side in Next.js. So since Next.js is a React framework, the rendering work is of course done by React itself following the rules about how components are rendered in the new React server components model that we have studied earlier. Now, we also already talked about server side rendering in general and about how server components are rendered. And so here, let's just remember that both server and client components are rendered actually on the server on the initial page render. But how does Next.js fit into this picture? You might ask. Well, Next.js uses the React and react-dom libraries in order to render each route one by one on the server Or in other words, Next.js a splits the rendering work by route, like these three routes of the same app, and each route can be rendered in a different way. In particular, each route can be either static, which is also called pre-rendered or dynamic. Now, we will learn about what each of these are in just a moment, but what matters for now is that it's not the entire app that is either rendered statically or dynamically, but really, each route individually. In this example, we have the route and the product page as static routes, and the search page is dynamic. Now, actually, besides these two rendering strategies, there's also one that basically mixes these two, and which is called partial pre-rendering, but more about that later in this section. But anyway, we've been talking about static and dynamic rendering all this time, but don't really know what they mean. And so let's change that. So in static rendering, the HTML for the route is generated at build time, which means that the markup is rendered whenever we run the build command in our Next.js app. So it's basically the developer who triggers the rendering. Now, there's also a special flavor of static rendering, which is called incremental static regeneration, which is just the fancy way of saying that a route can be re-rendered periodically in the background. So basically by refetching the routes data from time to time. But more about this by the end of the video. What matters is that static essentially means rendered just once at build time. And this is useful whenever the data for the route in question doesn't change very often, and most importantly, is not personalized to the user. So in the previous slide, we had a product page as a static page, which doesn't need any data that belongs to or is generated by the user. Now, on the other hand, dynamic rendering means that the HTML is generated at request time. Or in other words, the server renders a new version of the page for each request that hits the server. So in this strategy, it's actually the user who triggers the rendering. And this makes sense if the data changes constantly and is personalized to the user. And back to our e-commerce example, a shopping cart might be a good candidate for dynamic rendering because each user will have a different shopping cart, right? Dynamic rendering is also necessary whenever rendering the route requires information that depends on the request itself. For example, the search params from the URL or a cookie or something like a header. Now by default in Next.js, all routes are rendered statically, even when the page component or another component in the tree fetches some data. It's only under certain conditions, which we'll explore in the next slide that Next.js will actually switch a route to dynamic rendering. And the idea behind this is that static pages are way faster. First, because they have already been pre-generated and don't need to be rebuilt for every request, which saves time and resources. And second, because static assets like this can very easily be hosted on a so-called CDN, which means content delivery network. And this is what happens automatically for each route when we deploy our Next.js app to Vercel, which is the company that built the Next.js framework. On the other hand, each dynamic route when deployed to Vercel will automatically become a serverless function. And again, more about all this later in the lecture. Finally, I just want to mention that in certain situations like when we have no personalized user data at all, all routes in the app might actually be static. In this case, the entire app can be exported as a static site in a process that we call static site generation or SSG for short. Okay, but now, let's actually rewind and understand when exactly Next.js switches a route from static to dynamic rendering. Now, just saying this already implies that it's usually not us developers who directly choose whether a route should be statically or dynamically rendered. Instead, there are a few scenarios in which Next.js will automatically decide to switch from the default to dynamic rendering. The first one is that the route contains one or more dynamic segments, which means that the corresponding page uses the params prop in order to render some data that depends on the dynamic segments. Now, these dynamic segments can only be known at request time, and therefore, the route needs to become dynamic. The second scenario is that the routes page component reads some search param or also called query param from the URL. And an example of such a search param could be this quantity per right here, which is set to the value of 23. Next, if any of the routes' server components reads incoming headers or cookies, the route will also be switched to dynamic rendering as well. Now, it might seem strange that this alone makes Next.js render a route dynamically, but if we think about it, this actually makes sense because both the search params and headers and cookies cannot be known by Next.js at build time. They depend inherently on the incoming request, which means that the route must be rendered anew for each of these incoming requests, which is exactly what dynamic rendering does. But anyway, there is actually another factor that turns on dynamic rendering, which is an uncached data request in any of the server components that are part of the routes component tree. And this caching behavior is something that we can influence as we'll see later in this section. This means that we can basically force Next.js to render a route dynamically simply by manipulating the way fetch requests are cached. And so here are the different ways in which we can do that. Now, I'll not go through these here one by one, but I'll leave them here in this slide as a reference for you because I would've really liked to have one central place with all this information when I first learned about the Next.js app router. And of course, we're also going to use these in practice later on. And now to finish, we need to just define a few important terms that are relevant to this lecture and which are gonna pop up all the time. So things like CDN or serverless function that I mentioned earlier. Now, this is gonna be just a big wall of text, but please bear with me here as this is important stuff. So first off is the Content Delivery Network or CDN. So a CDN is a network of related servers that are located at many different positions around the globe. And these servers all cache. So they store a website's static content. So things like HTML, CSS, JavaScript, and images. And then deliver this content to each user from a server located as close as possible to that user. The advantage of this is that all this data then doesn't need to travel across the entire planet from the website's host to the user because it will just come from the server that's physically closest to the user. And most hosting providers like Vercel or Netlify or render.com will automatically host all your website's static assets on a global CDN like this. Another term that I used in a previous light, but what you might not know is a serverless function, which is related to serverless computing. So in the serverless computing model, we can run application code and usually backend code without managing the server ourselves. Instead, we can just run single functions on a cloud provider like AWS or Vercel or many others. And we call these functions serverless functions. So in this model, the server is initialized and active only for the duration that the serverless function is actually running. And so this is very different from, for example, a traditional Node.js app where the server is always running and never stops. Now, this is relevant to us because as I mentioned earlier, when we deploy our website to Vercel, each dynamic route will simply become one serverless function. So what this means is that our Next.js app is not simply one huge Node.js app that's running on a server, but instead a collection of serverless functions with the servers automatically managed by Vercel if that's where we choose to deploy the app. For example, if one of our routes gets a huge sudden boost in traffic, Vercel will automatically provide more resources for that serverless function in order to handle all that additional load. Now, of course, if we only have static routes, then none of this applies. Because in that case, all of these static routes will simply be built on build time and will then be hosted on A CDN as we just learned. Next up, one term you might hear from time to time is the word edge. Now, this one is a bit confusing, but we can think of the edge as anything that happens as close as possible to the user. So a CDN is definitely part of an edge network because files are indeed located as close as possible to each user. However, there is also serverless edge computing, and this is simply serverless computing that does not happen on a big central server like it usually does, but instead on a network that's distributed around the globe so that the computing, or in other words, the running of the serverless function can happen as close as possible to the user. So essentially, we can think of edge computing like a CDN, but for running code in the form of serverless functions. Now, this is important to know because if we choose to deploy our app to Vercel, we can select certain dynamic routes to actually run on the edge so that they become even faster because again, they will run closer to the user. Finally, incremental static regeneration or ISR for short is a Next.js feature that allows developers to essentially refetch and update the content of a static page in the background without the user ever noticing long after the original website has been built and deployed. This happens by re fetching the data of a certain component or of an entire route after a certain interval that we can define in our code has passed. Now, this concept is closely related to static pages, which is why I brought it up here as well. But we'll explore this in practice when we talk about caching later. All right, and with all this new information in our mind.