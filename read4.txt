 Next up, we're moving on to the reservation section that should be on each single cabin page. Now, to implement this feature, we need to fetch a few types of data, but we can do so in multiple places and multiple ways. And so we need to decide between all of that. So in this lecture, I want to discuss the different strategies that we can use when it comes to fetching multiple pieces of data on a single page, which is something very common that you'll probably face in your own apps, and which is vital to get right in order to build a nice user experience. So here is the code of our individual cabin page. So this one right here. And actually before we start and go even further, there's something that I want to do, which is right here in this title. I want to add the name of the cabin as well. So that's just cabin dot, or actually not, it is just name. Yeah, so that's a lot nicer and makes it a bit more personalized for each page. Alright, but now moving on to the actual reservation section, I already have built two components that we need for here. So we're gonna have a date picker on the left side where we can select a range of dates. And on the right side there is gonna be a form where the user can put in the name, the number of nights, and some other details. So let's start by simply placing those components right down here into a div. So below this h2 here. So just one div and then let's get those two components from the starter files. So down here we have the DateSelector and the ReservationForm. So we're gonna grab these two, place them right here. And so let's get the DateSelector first and then the ReservationForm. All right. And there immediately we get some error. And the reason for that is that this DateSelector here actually needs the react-day-picker dependency. So here we're using an external package, and so let's install that here. Npm install this very nice package. So let's reload here and now we get a problem. So here it's not really explicit why that problem is happening, but the reason is that this should be a client component because otherwise this create context that is necessary for the day picker is not gonna work. So let's add the use client directive here at the top. Then let's hope it's gonna work this time. And there we go. So there's the date picker, can probably select some ranges. Well, actually not yet, we haven't configured that yet. And then here is the form. Yeah, so just the number of guests because here we're actually gonna get the logged in user later. And then here, just some other stuff. Now we're missing here, some formatting, so, so let's make this a grid with two columns. So grid-cols-2. And I also want to give this a nice border. A border with the primary color in the shade of 800. And then also a minimum height. And here I actually already had selected the value of 400 pixels. So this is how we do that manually if we want to basically move out of the Tailwind configured values. And then it looks like here we need some margin to the bottom. So let's do that, mb, let's say 10. And also since we're already here, let's add the text color that all of our other headings also have. And nice. So this looks pretty nice here, but of course nothing here is working yet, so we don't have any data. And so that's what we need to think about next. So let's move into our DateSelector here. And immediately we can see that here we actually need from the settings the minimum booking length and the max booking length. So these are, remember from way back when we first built the first part of this project, we allowed the users to set some settings. So two of those settings were the minimum and the maximum booking length. So here we're using those in the day picker. So what this means is that we're gonna have to fetch these settings from our Supabase API. And then what we're also gonna need is the already booked dates. So that here in these calendars we can basically block out the dates that are already reserved because it doesn't make sense that the users can click here on dates that aren't even available for this cabin anymore. So these two pieces of data are going to be needed right here in this component. So keep those in mind. And then here in the ReservationForm, we also gonna need some stuff. So for now, all we need is this maximum capacity, which is going to come from the cabin itself. Okay? So basically in this one here, we need the settings and the bookings. And in here we need the cabin. And that cabin is actually also needed here in the DateSelector because as you see here, we have some prices here. So those prices are also gonna come from the cabin. So this means that we need basically three pieces of data. The current cabin that we already have up here with getCabin, then we need the bookings and the settings. So right here, let's go all the way up. So what we want here, yeah, getBookedDatesByCabinId. So this is a nice function that I already created where we pass in the cabinId and that will then get all the dates that have already been booked. So it's gonna create this data structure right here, so we don't have to worry about that. And then the other one is this getSettings function. All right? So let's get this data here onto this page. But first of all, why do we even fetch this data in this page and not in these components? Well, so not right here. Well first of all, the DateSelector is already a client component. And this one here will also have to be a client component. It is not yet one, but it will become a client component in the future. And so the idea is to not fetch the data in the client components, but on the server, and then pass it down as props. So as we've discussed already many times before. So let's then just fetch all this data. So let's say settings await getSettings like this, and then also the booked dates. So bookedDates equal await, getBookedDatesByCabinId. And so here, as we can imagine, we need to pass in again, params.cabinID. All right, so let's just see if this works. And yeah, we don't get any error here, so that's nice. But now let's try to introduce some problems into this approach that we have right here. So let's say that some of these queries here take a long time. So where have we that code? Yeah, let's use this one right here. Sorry. Yeah, let's actually activate this one. Let's make it two seconds. And then let's see the settings also take a lot of time. So also two seconds right here. So if we do this now, then this is going to take a lot more time. One, two, one, two seconds, or let's do that again. So it takes already some seconds while it's loading here. Then it takes all these additional seconds. And so those should actually be more than just two because, let's take a look, because here we actually have a blocking waterfall. So what this means is that we're fetching multiple pieces of data that don't really depend on each other, but that are still blocking one another. So this one here takes two seconds, so then everything else will have to wait. Then this one also takes two seconds. So then the next one will have to wait. And only after those two plus two seconds will this one here be able to get fetched. And so that's why this took so long to load here, which doesn't really make sense. Now, one approach to fixing this is to use Promise.all. And so then we can basically get this data in parallel. So the way that would work is to use Promise.all, and then here we pass in an array of promises. So that's this one, then this one, and then this final one. So these three here create promises, right, which we then await. Yeah, so without the await exactly, and then we await all of that, await, and then we can, so we then receive an array with the results, which we can then immediately destructure, so we can then create cabin, settings, and bookedDates. We then need to deactivate these. And so let's see if we can visually already see that this is a bit faster. And yeah, I think it was faster. However, this is still not perfect because this can only be as fast as the slowest promise. So if like getSettings takes like five seconds, then this is still be a pretty long blocking operation. So it now took probably five seconds, while before it would've taken two plus five seconds. So this is already better, but we can do even better than this. So instead of fetching all the data here on the parent page, we can just create a bunch of different components and then have each component fetch all the data that it needs, and then those components can be streamed in as they become ready. So I believe that that is a much better strategy than just doing this. So again, fetching all the data here at the parent. So let's do that. So what I'm gonna do first here is to create a component which will contain these two client components here. And so that component will then only fetch the data that is required for this one and for this one. So let's call that one Reservation.js. Let's do again this. And so then I'm just gonna grab this right here, place that here. And then we need to of course, do these imports just like this. And then we place that here. So Reservation. And yeah, of course, we then should also get rid of these imports right here. And by the way, a nice shortcut in VS Code that will help you to automatically get rid of unused imports is shift + alt + O. Okay, so I just clicked that, and so this cleaned up my imports just nice. I think it also kind of reoriented them a little bit. But anyway, what matters is that now we have, yeah, we now have the Reservation which contains the DateSelector and the ReservationForm. And so let's now grab the data that we need here. And so what we need there is the settings. Remember the booked dates, but also the cabin itself. Now there's no need to fetch the cabin twice. And so what we're gonna do is to leave the cabin actually here, because we also need it right here, right? And then let's take all of this, or actually, I wanted to do the other way around. So I wanted to just leave the cabin here and place this one here, make this an async function. And then we're not gonna grab the cabin here, but only the settings and the bookedDates. So importing those functions here, just like that. Now we can remove them from here again with a shortcut of shift + alt or shift + option + O. Nice. Now, I'm not sure why the getCabins... Oh yeah, of course here, because of the generateStaticParams. Okay, let's actually remove this entirely. And now finally, in order to activate streaming for only this component, remember how we do that. So right now, probably nothing is really gonna change. Well, first of all, we have this error because of this params, and that makes sense. So here that is not even defined. So here, we're gonna need to accept the cabin, because remember, we're gonna need this here anyway, so let's do cabin.id. And this should then work better. And again, we are not fetching this cabin here also because we also need it here in the page already, so we can just pass it down as a prop. And of course we need to pass it also in here. And then, let's see. So reloading that. And now for now, still everything looks the same. So we still have that blocking UI where just fetching this data here basically makes it so that the entire page cannot be rendered in. So yeah, here we still have the five seconds for getting the settings, but now I'm gonna remove that waiting time from the getCabin, but still this is going to take all that time and the entire page is blocked only because those settings are taking five seconds to load in. And so now it's time to fix that using streaming. Alright, now we already have streaming active, of course, because otherwise we wouldn't even have that spinner there in the first place. But that streaming is coming from the loading.js file, which remember acts for the entire route. But now we want something more granular and therefore we use, remember, Suspense, we already did that earlier, but here it's time to use that again, and remember how it works. And so in the meantime, while that data is still coming in into the reservation, so while reservation is suspending, here we want to render the loading spinner that we have been used in other places as well. So let's save, let's reload. And immediately that data now comes in and now the five seconds pass while only this reservations component is being fetched. So huge, huge difference, right? Let's see that again. So as soon as the user arrives on this page, they are immediately able to read this data and then if the settings stay five seconds, then they will have to wait a little bit here. But that's not a big deal. At least the part in the beginning is already visible. And so again, that happened because we activated a more granular streaming experience by wrapping this suspending component into Suspense. And so this was one of the big reasons why we moved all this data that is really only needed here into this Reservation component. So we couldn't move it into these two because these are client components, and so we cannot fetch there. But here on the server in this one, we can fetch. And so this is how we do it right now. And so just to finish, let's just pass in all the data that we actually need here. So settings, set to settings, bookedDates, set to bookedDates, and cabin, set to cabin. Now ideally, client components should actually only be passed the minimal amount of data. So here we are passing in the entire objects, like the entire settings and the entire cabin, even though we probably are not going to need all of it. But if we need still like three or four things from the cabin, then two or three settings, we end up with like 10 props. And that seems a bit unmanageable. And so in this case, we're just doing it like this. But if for example, all we needed was two properties of the cabin, for example, the capacity and the price, then maybe we should only pass those two as props. All right. And now here in the form, we also need the cabin, for example, here to generate the number of guests. So this is now hard coded to 23, but of course it's going to change depending on each guest. Or actually on each cabin. Alright, so this part here is done for now. Of course, we still need to work a lot on the DateSelector and the ReservationForm to actually make them work. But for now, all we're gonna do is to just accept those props here. So that's the settings, the cabin, and the bookedDates. I think it's spelled like that. And here we can also immediately maybe grab these values out of there. So out of the settings. But then we're gonna take care of the rest of the stuff later. So the cabins and the bookedDates. So for now, let's keep these placeholder values here. And then finally, let's also accept the cabin right here. Now, maybe let's grab the maxCapacity out of the cabin already, using the structuring as always, just so we see that now the values are gonna be read dynamically. So now it can only be one or two guests. Beautiful. So I hope all of this made sense, all these different strategies that we just discussed here. And let's now just remove this one from here because of course this doesn't make any sense, right? So when you're gonna build your own applications in the future, you'll always need to have these kinds of thoughts and discussions basically with yourself about these strategies and patterns of data fetching in your own applications. So this is what makes a great developer and also leads to a great user experience, like the one that we just built here. So again, we're not blocking the entire UI, but instead immediately showing this one here. And then later, as soon as all the data that's necessary for this component here becomes necessary, only then it can be rendered. So only then it will no longer be suspending. And now just one final thing I want to do here is to grab all of this code here and make this page a lot cleaner. So taking this here and exporting it into its own cabin component. So let's make a new component here, Cabin.js, RFC. And so this one now also needs to get the cabin. And so then I guess we don't even need this part here anymore. So let's just take this cabin. Well, maybe... Well, I guess it should be exported, but I guess there's some problem here. So what's that? No corresponding closing tag. So let's give it that closing tag then. And so then we should be able to import that here. Yep. And let's pass in the entire cabin. And then we no longer need this stuff right here. We're just gonna need it here. So cabin.name. So we're gonna fix this error there later. Oh, come on. What's happening now? Okay, let's go back. So I'm gonna cut that here, paste it here. Nice. Accept the prop, import the image component. So import Image from next/image. And so, ah, it also, well, let's go here and grab all the stuff that we actually need. So that's this text expander and these icons. So cut those from here. And there we go. So that's no longer red. So this one should work now. And now we're probably missing some divs here, or maybe we have one too much, I guess more like this. Yeah, and now finally, as we mentioned earlier, here, we actually need cabin.name 'cause we are no longer destructuring. All right. And by the way, since we're already here, this cabin.name right here is the reason why we cannot fetch the cabin data right here in Cabin and also inside Reservation. So we need also cabin right here in the page. So we need basically the cabin data in this page. We need it inside this Cabin component, and we need it inside this Reservation component. So inside all of those. Now remember from the cache lecture, there is something called request memorization, which allows us to do a similar fetch request in multiple places of the tree, and it will then get de-duplicated. And so then only one request to the original data source will be made. So we could make use of that here. But in situations like this, I like to just keep it simple and fetch it once and yeah, then just pass it as a prop because these components are really only one level deep. If it was a big and deep tree, then it would make sense to just fetch it in multiple places. But here it's just one level. So we just fetch the data here in one place and then just pass it as a prop. So let's reload. Everything works, nice and beautiful. And so we're finished here. And in the next lecture, we're finally gonna start working on making this here work. So please make sure, once again, to understand really deeply what we did here, and to analyze the way that the data flows throughout this page and all these different components, why we use Suspense and so on. So this is again, really important stuff. And so take your time to understand this. Next up, we're moving on to the reservation section that should be on each single cabin page. Now, to implement this feature, we need to fetch a few types of data, but we can do so in multiple places and multiple ways. And so we need to decide between all of that. So in this lecture, I want to discuss the different strategies that we can use when it comes to fetching multiple pieces of data on a single page, which is something very common that you'll probably face in your own apps, and which is vital to get right in order to build a nice user experience. So here is the code of our individual cabin page. So this one right here. And actually before we start and go even further, there's something that I want to do, which is right here in this title. I want to add the name of the cabin as well. So that's just cabin dot, or actually not, it is just name. Yeah, so that's a lot nicer and makes it a bit more personalized for each page. Alright, but now moving on to the actual reservation section, I already have built two components that we need for here. So we're gonna have a date picker on the left side where we can select a range of dates. And on the right side there is gonna be a form where the user can put in the name, the number of nights, and some other details. So let's start by simply placing those components right down here into a div. So below this h2 here. So just one div and then let's get those two components from the starter files. So down here we have the DateSelector and the ReservationForm. So we're gonna grab these two, place them right here. And so let's get the DateSelector first and then the ReservationForm. All right. And there immediately we get some error. And the reason for that is that this DateSelector here actually needs the react-day-picker dependency. So here we're using an external package, and so let's install that here. Npm install this very nice package. So let's reload here and now we get a problem. So here it's not really explicit why that problem is happening, but the reason is that this should be a client component because otherwise this create context that is necessary for the day picker is not gonna work. So let's add the use client directive here at the top. Then let's hope it's gonna work this time. And there we go. So there's the date picker, can probably select some ranges. Well, actually not yet, we haven't configured that yet. And then here is the form. Yeah, so just the number of guests because here we're actually gonna get the logged in user later. And then here, just some other stuff. Now we're missing here, some formatting, so, so let's make this a grid with two columns. So grid-cols-2. And I also want to give this a nice border. A border with the primary color in the shade of 800. And then also a minimum height. And here I actually already had selected the value of 400 pixels. So this is how we do that manually if we want to basically move out of the Tailwind configured values. And then it looks like here we need some margin to the bottom. So let's do that, mb, let's say 10. And also since we're already here, let's add the text color that all of our other headings also have. And nice. So this looks pretty nice here, but of course nothing here is working yet, so we don't have any data. And so that's what we need to think about next. So let's move into our DateSelector here. And immediately we can see that here we actually need from the settings the minimum booking length and the max booking length. So these are, remember from way back when we first built the first part of this project, we allowed the users to set some settings. So two of those settings were the minimum and the maximum booking length. So here we're using those in the day picker. So what this means is that we're gonna have to fetch these settings from our Supabase API. And then what we're also gonna need is the already booked dates. So that here in these calendars we can basically block out the dates that are already reserved because it doesn't make sense that the users can click here on dates that aren't even available for this cabin anymore. So these two pieces of data are going to be needed right here in this component. So keep those in mind. And then here in the ReservationForm, we also gonna need some stuff. So for now, all we need is this maximum capacity, which is going to come from the cabin itself. Okay? So basically in this one here, we need the settings and the bookings. And in here we need the cabin. And that cabin is actually also needed here in the DateSelector because as you see here, we have some prices here. So those prices are also gonna come from the cabin. So this means that we need basically three pieces of data. The current cabin that we already have up here with getCabin, then we need the bookings and the settings. So right here, let's go all the way up. So what we want here, yeah, getBookedDatesByCabinId. So this is a nice function that I already created where we pass in the cabinId and that will then get all the dates that have already been booked. So it's gonna create this data structure right here, so we don't have to worry about that. And then the other one is this getSettings function. All right? So let's get this data here onto this page. But first of all, why do we even fetch this data in this page and not in these components? Well, so not right here. Well first of all, the DateSelector is already a client component. And this one here will also have to be a client component. It is not yet one, but it will become a client component in the future. And so the idea is to not fetch the data in the client components, but on the server, and then pass it down as props. So as we've discussed already many times before. So let's then just fetch all this data. So let's say settings await getSettings like this, and then also the booked dates. So bookedDates equal await, getBookedDatesByCabinId. And so here, as we can imagine, we need to pass in again, params.cabinID. All right, so let's just see if this works. And yeah, we don't get any error here, so that's nice. But now let's try to introduce some problems into this approach that we have right here. So let's say that some of these queries here take a long time. So where have we that code? Yeah, let's use this one right here. Sorry. Yeah, let's actually activate this one. Let's make it two seconds. And then let's see the settings also take a lot of time. So also two seconds right here. So if we do this now, then this is going to take a lot more time. One, two, one, two seconds, or let's do that again. So it takes already some seconds while it's loading here. Then it takes all these additional seconds. And so those should actually be more than just two because, let's take a look, because here we actually have a blocking waterfall. So what this means is that we're fetching multiple pieces of data that don't really depend on each other, but that are still blocking one another. So this one here takes two seconds, so then everything else will have to wait. Then this one also takes two seconds. So then the next one will have to wait. And only after those two plus two seconds will this one here be able to get fetched. And so that's why this took so long to load here, which doesn't really make sense. Now, one approach to fixing this is to use Promise.all. And so then we can basically get this data in parallel. So the way that would work is to use Promise.all, and then here we pass in an array of promises. So that's this one, then this one, and then this final one. So these three here create promises, right, which we then await. Yeah, so without the await exactly, and then we await all of that, await, and then we can, so we then receive an array with the results, which we can then immediately destructure, so we can then create cabin, settings, and bookedDates. We then need to deactivate these. And so let's see if we can visually already see that this is a bit faster. And yeah, I think it was faster. However, this is still not perfect because this can only be as fast as the slowest promise. So if like getSettings takes like five seconds, then this is still be a pretty long blocking operation. So it now took probably five seconds, while before it would've taken two plus five seconds. So this is already better, but we can do even better than this. So instead of fetching all the data here on the parent page, we can just create a bunch of different components and then have each component fetch all the data that it needs, and then those components can be streamed in as they become ready. So I believe that that is a much better strategy than just doing this. So again, fetching all the data here at the parent. So let's do that. So what I'm gonna do first here is to create a component which will contain these two client components here. And so that component will then only fetch the data that is required for this one and for this one. So let's call that one Reservation.js. Let's do again this. And so then I'm just gonna grab this right here, place that here. And then we need to of course, do these imports just like this. And then we place that here. So Reservation. And yeah, of course, we then should also get rid of these imports right here. And by the way, a nice shortcut in VS Code that will help you to automatically get rid of unused imports is shift + alt + O. Okay, so I just clicked that, and so this cleaned up my imports just nice. I think it also kind of reoriented them a little bit. But anyway, what matters is that now we have, yeah, we now have the Reservation which contains the DateSelector and the ReservationForm. And so let's now grab the data that we need here. And so what we need there is the settings. Remember the booked dates, but also the cabin itself. Now there's no need to fetch the cabin twice. And so what we're gonna do is to leave the cabin actually here, because we also need it right here, right? And then let's take all of this, or actually, I wanted to do the other way around. So I wanted to just leave the cabin here and place this one here, make this an async function. And then we're not gonna grab the cabin here, but only the settings and the bookedDates. So importing those functions here, just like that. Now we can remove them from here again with a shortcut of shift + alt or shift + option + O. Nice. Now, I'm not sure why the getCabins... Oh yeah, of course here, because of the generateStaticParams. Okay, let's actually remove this entirely. And now finally, in order to activate streaming for only this component, remember how we do that. So right now, probably nothing is really gonna change. Well, first of all, we have this error because of this params, and that makes sense. So here that is not even defined. So here, we're gonna need to accept the cabin, because remember, we're gonna need this here anyway, so let's do cabin.id. And this should then work better. And again, we are not fetching this cabin here also because we also need it here in the page already, so we can just pass it down as a prop. And of course we need to pass it also in here. And then, let's see. So reloading that. And now for now, still everything looks the same. So we still have that blocking UI where just fetching this data here basically makes it so that the entire page cannot be rendered in. So yeah, here we still have the five seconds for getting the settings, but now I'm gonna remove that waiting time from the getCabin, but still this is going to take all that time and the entire page is blocked only because those settings are taking five seconds to load in. And so now it's time to fix that using streaming. Alright, now we already have streaming active, of course, because otherwise we wouldn't even have that spinner there in the first place. But that streaming is coming from the loading.js file, which remember acts for the entire route. But now we want something more granular and therefore we use, remember, Suspense, we already did that earlier, but here it's time to use that again, and remember how it works. And so in the meantime, while that data is still coming in into the reservation, so while reservation is suspending, here we want to render the loading spinner that we have been used in other places as well. So let's save, let's reload. And immediately that data now comes in and now the five seconds pass while only this reservations component is being fetched. So huge, huge difference, right? Let's see that again. So as soon as the user arrives on this page, they are immediately able to read this data and then if the settings stay five seconds, then they will have to wait a little bit here. But that's not a big deal. At least the part in the beginning is already visible. And so again, that happened because we activated a more granular streaming experience by wrapping this suspending component into Suspense. And so this was one of the big reasons why we moved all this data that is really only needed here into this Reservation component. So we couldn't move it into these two because these are client components, and so we cannot fetch there. But here on the server in this one, we can fetch. And so this is how we do it right now. And so just to finish, let's just pass in all the data that we actually need here. So settings, set to settings, bookedDates, set to bookedDates, and cabin, set to cabin. Now ideally, client components should actually only be passed the minimal amount of data. So here we are passing in the entire objects, like the entire settings and the entire cabin, even though we probably are not going to need all of it. But if we need still like three or four things from the cabin, then two or three settings, we end up with like 10 props. And that seems a bit unmanageable. And so in this case, we're just doing it like this. But if for example, all we needed was two properties of the cabin, for example, the capacity and the price, then maybe we should only pass those two as props. All right. And now here in the form, we also need the cabin, for example, here to generate the number of guests. So this is now hard coded to 23, but of course it's going to change depending on each guest. Or actually on each cabin. Alright, so this part here is done for now. Of course, we still need to work a lot on the DateSelector and the ReservationForm to actually make them work. But for now, all we're gonna do is to just accept those props here. So that's the settings, the cabin, and the bookedDates. I think it's spelled like that. And here we can also immediately maybe grab these values out of there. So out of the settings. But then we're gonna take care of the rest of the stuff later. So the cabins and the bookedDates. So for now, let's keep these placeholder values here. And then finally, let's also accept the cabin right here. Now, maybe let's grab the maxCapacity out of the cabin already, using the structuring as always, just so we see that now the values are gonna be read dynamically. So now it can only be one or two guests. Beautiful. So I hope all of this made sense, all these different strategies that we just discussed here. And let's now just remove this one from here because of course this doesn't make any sense, right? So when you're gonna build your own applications in the future, you'll always need to have these kinds of thoughts and discussions basically with yourself about these strategies and patterns of data fetching in your own applications. So this is what makes a great developer and also leads to a great user experience, like the one that we just built here. So again, we're not blocking the entire UI, but instead immediately showing this one here. And then later, as soon as all the data that's necessary for this component here becomes necessary, only then it can be rendered. So only then it will no longer be suspending. And now just one final thing I want to do here is to grab all of this code here and make this page a lot cleaner. So taking this here and exporting it into its own cabin component. So let's make a new component here, Cabin.js, RFC. And so this one now also needs to get the cabin. And so then I guess we don't even need this part here anymore. So let's just take this cabin. Well, maybe... Well, I guess it should be exported, but I guess there's some problem here. So what's that? No corresponding closing tag. So let's give it that closing tag then. And so then we should be able to import that here. Yep. And let's pass in the entire cabin. And then we no longer need this stuff right here. We're just gonna need it here. So cabin.name. So we're gonna fix this error there later. Oh, come on. What's happening now? Okay, let's go back. So I'm gonna cut that here, paste it here. Nice. Accept the prop, import the image component. So import Image from next/image. And so, ah, it also, well, let's go here and grab all the stuff that we actually need. So that's this text expander and these icons. So cut those from here. And there we go. So that's no longer red. So this one should work now. And now we're probably missing some divs here, or maybe we have one too much, I guess more like this. Yeah, and now finally, as we mentioned earlier, here, we actually need cabin.name 'cause we are no longer destructuring. All right. And by the way, since we're already here, this cabin.name right here is the reason why we cannot fetch the cabin data right here in Cabin and also inside Reservation. So we need also cabin right here in the page. So we need basically the cabin data in this page. We need it inside this Cabin component, and we need it inside this Reservation component. So inside all of those. Now remember from the cache lecture, there is something called request memorization, which allows us to do a similar fetch request in multiple places of the tree, and it will then get de-duplicated. And so then only one request to the original data source will be made. So we could make use of that here. But in situations like this, I like to just keep it simple and fetch it once and yeah, then just pass it as a prop because these components are really only one level deep. If it was a big and deep tree, then it would make sense to just fetch it in multiple places. But here it's just one level. So we just fetch the data here in one place and then just pass it as a prop. So let's reload. Everything works, nice and beautiful. And so we're finished here. And in the next lecture, we're finally gonna start working on making this here work. So please make sure, once again, to understand really deeply what we did here, and to analyze the way that the data flows throughout this page and all these different components, why we use Suspense and so on. So this is again, really important stuff. And so take your time to understand this. To round off this section, let me now show you how we can essentially build an API endpoint right from Next.js using a feature called Route Handlers. Now, first of all, creating our own API endpoints in Next.js is not as important anymore as it was previously in the Pages Router, because now, in order to mutate data, we have server actions. And so previously, in the Pages Router, the main way of mutating data was to create API endpoints. But again, that's no longer really necessary in Next.js now, because with the React Server Components architecture, we also have server actions now, but more about that a bit later in the course. But anyway, we still want to learn how we can create our own API endpoints, and for that, we use a feature called Route Handlers. So we can create a route handler by creating yet another convention file called route.js in this case, and this route.js file can be in any folder that doesn't have a page.js yet. And that's important because when a request is sent to the URL that corresponds to the route handler, no HTML is returned, but instead, the route handler is gonna be executed and then usually returns some JSON data. And so if there was also a page.js file in the same folder, that would then create a conflict, because of course, we cannot send HTML and JSON data at the same time. Now, all right. But anyway, let's then now create a new folder here for a new route, because we need to create a route just like we did for all our pages. And so let's call that route, of course, we actually need a new folder, and so let's just call this api for now, and then in here, we create not page.js, but route.js. Now, okay. Now from this route.js, we can export one or more functions where each of them can correspond to one of the HTTP verbs. So we can have the most basic one, an async function called GET, and so this one is for a GET request, just like this. And as you can imagine, if we wanted to make a POST request to this URL, then we could also export a POST function. And we can also do PUT, PATCH, DELETE, HEAD and OPTIONS. So all of those are HTTP verbs, and so we can create one route handler for each of those verbs. Now in this case, all we're interested in here is a GET route, so making a GET request to this API endpoint. Now, in order to send back a response or even to check out the request itself, these route handlers use web standards such as Request and Response. For example, doing Response.json. And again, this response right here is actually not a Next.js feature, but really, a web standard that has been implemented in browsers as well. So you can, for example, Google MDN Response API, and so yeah, then here you can read about this documentation. And so not on Next.js, but really on MDN, which is kind of a website where we can read all kinds of documentation about JavaScript, web standards, and stuff like that. Now, we can actually also use some extended Next.js versions of Response, but you can check that out in the documentation if you want. So in a simplest form, we can just use this Response web API, .json, and then here we can send back some response. Let's just place some object here, test set to "test," and so if we now navigate to this URL, so to this route that we just created, which is just /api, we should get back that data. And we didn't because we actually need to return this. So let's try that again, and indeed, there is our result. So the JSON that we created here was now sent to this route. So no HTML, but really, JSON data. So again, that's the reason why we could not have a page.js also in this folder. Okay, now to create something useful here, as an example, we're gonna build an API endpoint for affiliates where these affiliates can get data about a cabin based on an ID passed as a parameter. So for example, that can be, let's say, api/cabins/89, so basically something similar like we already have, but without the api part here. So what we want is to build a route that is api/cabins, and then here, some variable ID. So it could also be 90, and so on. So again, similar to what we already have here. So let's do that. So api, create a new folder for a new route segment, and then here, the dynamic segment in there. So we need another folder, and so let's call this one, just like before, cabinId. And so now, that route needs to go in there. All right, so let's load this here now, and beautiful, we get our data, but of course, it doesn't contain this ID here yet. But we can get that very easily here. So the first argument that this function actually receives is the request itself, and then we get an object which contains the params. So let's log both of them to the console, so request and params. Let's close this one here. Let's open this again. And indeed, there we have some stuff about our request, like all the headers, and yeah, really all kinds of stuff here, and then finally, we also get the cabinId. And so that's, once again, exactly the name that we gave this folder. So that's a bit hidden here, so we cannot really see that, but we see it here. So that's why this is called, again, cabinId, because that's the name of the folder in the square brackets. So the request, we're not really interested in here, but we still need to accept it here because that's the first argument of the function. But anyway, let's now grab that cabinId from the params. And now, what we need to do is to fetch all the data about this specific cabin, and we also want to get all the booked dates for this cabin in the future. And so this is the data that we want to provide to our imaginary affiliates. And doing it like this, so creating our own API endpoint, is really nice because this way we don't have to expose or Supabase API endpoint to these affiliates. Plus, we can also very easily aggregate different data sources from parts of the Supabase API that are not even publicly accessible. And while doing this, we can also keep our API keys hidden. So basically, creating a nice and easy to use abstraction for someone who might want to consume our data in a custom way, so a way that we can customize right here. So let's fetch that data actually in a try catch, because here we need some error handling, because the error boundaries that we set up for the Next.js app are of course not going to work here. So let's start with getCabin, where we pass in the cabinId, and remember that we need two data points here. And so let's actually fetch those inside a Promise.all. So we need to create an array, then Promise.all, and then we await that and store the result that we get and immediately destructure it into cabin and bookedDates. So that's one of them, and the other one is getBookedDatesByCabin, and again, this needs the cabinId. All right, of course, we need a catch here as well, and so in the case of success, we want to return an object which contains both the cabin and the bookedDates, and if there is some error, then let's return some other response. Response.json, and let's just specify a message here, and let's just say, "Cabin not found." All right, let's see if this is already working. So we are at cabin 90 here, so should take some time. And indeed, here is all the data about the cabin and also the booked dates. So it's an empty array right now, because we didn't book anything yet, but later on, this will actually work. And if we do something that does not exist, then indeed, we get "Cabin not found," because, well, one of these two here will throw an error, and so this try block will fail, and this one here will get sent instead. And all right, and so that's it. This is how we create our own custom endpoints, right in Next.js, which again, is not that common and not that useful anymore, because now we have server actions. But in case you ever need it, then here is how that works. Just keep in mind that we here, don't give this our own custom names, so these functions really need to be called the name of the HTTP verb that we are making the request with. So that's GET or POST, PUT, PATCH, DELETE, and so on. All right, and so that finishes the section. Next one is the very, very exciting section where we finally implement authentication. So don't wait, and let's move on there right away.

