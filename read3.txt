 Welcome back. So this section is all about possible interactions between the client and the server part of applications that follow the React server component's architecture. And so let's begin this section by taking a look at how this new architecture really blurs the lines between our traditional notions of server and client. And to start, let's just review what those traditional notions of server and client actually are. So in our traditional model, we have a server where our back-end runs, for example, a node JS API and a client where each user runs our front-end application, like for example, a React application. So in this slide, I really want to focus on the applications themselves, which is why in the diagrams we have back-end and front-end instead of server and client. But anyway, these back-end and front-end are very well separated in our minds and they usually also have different code bases and might even be hosted on different platforms. So there is a very clear boundary between the server and the client here. Now the communication between these two parties usually happens using an API that we implement on the back-end. And with that API, the front-end will be able to make get requests to fetch some data from the API usually in the format of JSON. Now as soon as that JSON data arrives from the back-end, the front-end completely takes over and the back-end is no longer involved in rendering the data and the UI at all. In most cases, the back-end is still needed though because usually APIs also allow the front-end app to perform mutations on the data. So to change the data in the back-end database by making post, put, delete or other types of requests. So again, all communication between back- and front-end happens through this API in the traditional model now, right? But now let's move on to how things work in Next.js with React server components and server actions, which is something we will learn about later. So in this RSC model that we've been using, a component tree might look something like this where the yellow components are server components and the blue ones client components. And that's what's so interesting about this is that we can imagine these types of components, SR applications, back-end and front-end spread all throughout the component tree. So there is no clear separation between the application's front-end and back-end like we have in a more traditional model. The lines between the front-end and back-end are completely blurred, and the boundaries between them are flexible and dynamic. For example, at the top of the tree, we are on the back-end with this server component. And then on the left, there's a child that's a client component. And so we're on the front-end now and then below that we are suddenly on the back-end again. So the pieces of server code and client code are kind of interweaved here, which is a pattern that has been called knitting. This interweaving, so this knitting is a powerful mechanism to compose the domains of server and client all into one true full-stack application living in just one code base and one React component tree. And this is the true beauty of the React server component's architecture that we've been using and that will explore even deeper in this section.
 
 So we've learned about the many advantages that the React server components paradigm brings to the table, but the fact that there is no clear boundary between back-end and front-end anymore is what makes this so special. Now, you might be thinking, isn't separation actually a good thing? Well, not always. So we used to think that a separation of concerns between HTML, CSS and JavaScript was very important, but then React came along with its component model and allowed us to write all three of them in just one single component, mixing everything together. And this was great and is now the dominant way of building any front-end apps in any framework. And I'm sure that the same thing will happen here with React server components. It'll take some time getting used to this mixing of server and client, but I'm absolutely sure that it will be beneficial in the end. Now, one immediate consequence of all this is that in many cases we no longer need to even build an API that acts as an intermediary between back-end and front-end. We can just easily switch between these domains at any point in the tree. And so we don't need an artificial API boundary to fetch and mutate data. So here's how these two operations work instead in the RSC model. So, as for fetching data, as we already know, we can simply get some data into a server component, for example, reading straight from a database and then render the data directly in the server component. Or as an alternative, if we need that data on the front-end, we can just send it to a client component in the form of props. Again, no need for an API here. And this of course works between any combination of server and client components. Now, about mutating data, we have never talked about how to do mutations in a Next.js application within the RSC model. So as part of React's full stack architecture vision, we have something called server actions that we can use to mutate data on the server directly from client components, but more about what server actions are a bit later. But, essentially using them replaces the post, put, and so on requests that we would typically make to the back-end API. Alright, now this isn't the most practical stuff, but I believe that it's highly important that you understand this fundamental difference between the traditional and the RSC paradigm. Now if you do want something more practical, we also have to talk about the difference between importing components and rendering them. So here we have the same component tree as in the previous slide, but now I gave them names from A to E, and one component is now a client component. And in this component tree, it's important to remember that a line means that the parent component renders the child component that it's connected to.

Now to start, I want to draw your attention to this situation right here where a client component renders a server component. And this seems kind of counterintuitive and impossible, right? I mean, once we're on the client, there should be no going back to the server. Well, there's actually an important trick that allows us to do just this. So we can render a server component inside a client component if we pass the server component as a prop. And this can be the children prop or any other regular prop. But let's look at some code. So here, first we're using client component B, so we're creating an instance of B and pass into it an instance of server component D as the children prop. And this is where the magic lies. So this whole thing works because at the point in which the server component instance D is passed as a prop, it has already been imported and executed on the server. So for this scenario to be possible, component A needs to import not only B, but also component D. And this brings us to something we call the dependency tree. So this is a tree that shows modules being imported by other modules. And so here, the lines mean that the parent module imports the child module. Notice how this tree is actually different from the component tree because again, component A actually needs to import component B and D for this code to work. Otherwise without first importing component D, D could not be passed as a prop. Okay. Now before recapping what just happened here, it's important to understand that in the React server components model, it's actually in this dependency tree where the client server boundaries are established, not in a component tree, but really in this dependency tree. This means that client components cannot import server components, only other client components. So it's not possible to go back over the client server boundary and import server components from the client. Client components can, however, render server components as long as these have been passed as props as we just learned. And let's now recap why that is possible. So in our example, again, component A is importing both component B and D. This way, server component D can be executed right here in server component A before being passed to the client. So, into client component B. So we are in fact not going back to the server in order to render D. Again, because an instance of server component D has already been created on the server and only then it's passed to the client, therefore it appears below B in the component tree because it's clearly and effectively a child component. But in the dependency tree, it has been imported inside A. This way the client server boundary has not been crossed, which is the only thing that matters to React. And now just to finish this table, server components can of course import and render all components. And by the way, we already had this exact part of the table in the very first video about React server components. Back then, this probably didn't make any sense, but hopefully now it does make at least some sense. All right, but we're still not done with this slide because I want to show you another interesting thing here. So notice how here, component E is importing a client component C. However, if we look closely at the tree, we see that component C is also a server component. So how can that be? Is C a server component or a client component? Well, the quick answer is that it can be both. But let's try to understand this from the start. So a component is really just a definition, like a blueprint. We can use a component multiple times throughout our app, which will create a component instance each time that we use that component. Now in the RSC model, if a component doesn't have the used client directive at the top of the module, then by default it will become an instance of a server component as soon as it's used. And that's exactly what's happening here as component C is imported by server component A. So again, C has no use client directive, and therefore by default, this instance of the component is a server component. But what about the second time component C is used at the bottom of the tree? Well, first of all, we know that components B and E have the use client directive because they clearly create client server boundaries, right? So again, client component E has the use client directive. Now it's this client component that is importing component C here. So what's gonna happen now? Well, this time component C is used, a client component instance will be created. Again, because C is imported by a client component. And as we already know, children of client components will automatically become client components as well. And so that's how we end up with component C being a server component instance in one place and a client component instance in another place off the tree. And again, for this to make sense, it's very important to understand that components actually create instances when they are used and that therefore the type of component instance that will be created is not set in stone when we write the component code. If the component is imported and used by a client component, so inside the client server boundary, it'll end up creating an instance of a client component too. Otherwise an instance of a server component is created instead. So just like at the first usage of C at the top of the tree. All right, that's all I have for you in this lecture. 

And so let's go back to our project now. So the first interaction that we're gonna look at is to use a Client Component in a Server Component. Now, we already did that earlier of course, but let's now do it again with our new knowledge. So here, we are in our cabins page, and let's say that this text here is a bit too long. So maybe in the beginning, we don't want to render all of this text here, but maybe show like a preview of the text and then have a button where the user can click and then that will expand the text and show all of it. So that's something that's common in many web applications, but for that, we need, of course, some interactivity. So if the user can click a button and then something will happen, well that's, of course, some interactivity powered by JavaScript, and in this case by React. So that means that we can no longer render that on the server, but need to move now to the client. Or in other words, we now need to create a Client Component for that functionality. So we're gonna place that Client Component right here in this Page Component, which again, is a Server Component. So with this text, this description right here. Now I already created that component, so that's that TextExpender here, or I started, at least, creating it. And so let's place that into our component folder, grabbing it from the starter files, and so here it is. So you can check out the basic functionality here, but basically, we just have a piece of state which tracks whether the text is currently expanded or not. And if it is expanded, so then we want to show or to render the whole text, then the displayText variable here becomes the children. So children prop is basically the text that we pass into this component. Now, all right. Otherwise, we only take the first 40 words like this. So there was no need for us to write this code together here because this is just some simple JavaScript that we have done so many times in the course. So let's try to use this and see what happens. So let's place that TextExpander right here into this paragraph. So TextExpander, and then we just grab that description and place that there. Let's see what happens. And indeed, we get an error. So you're importing a component that needs useState. It only works in a Client Component, but none of its parent are marked with "use client," and so they're Server Components by default. And so this stuff right here contains a lot of the things that we just learned in the previous lecture, right? And so the way in which we fix this, as you can guess, is by using the "use client" directive. And so with this, we now cross the server-client boundary and are now on the client, and this text that we receive here, so basically this data that is passed here from the server to the client, is now passing over the server-client boundary as well. And so we see that now it works, as we click here, then the text expands, and we can read all of it. The image then also changes a bit, and so this creates a really nice effect, which, again, we could only achieve by moving to the client. And that's of course perfectly fine. So Client Components are just as valid as Server Components, because most applications, of course, still need some interactivity like this. Now that being said, we should always, whenever possible, move Client Components as low into the component tree as possible, because as we already know, all child components of Client Components will be Client Components by default, and so they will then not be server rendered, even if they could be rendered on the server perfectly fine. And so whenever it's possible to render on the server, that's of course preferable because it makes the initial page load faster. All right, but in this case, this is clearly at the end of the tree, so as we say, a leaf of the tree, because there's no more child components in here. But now let's actually demonstrate one of the things that we looked at in the previous lecture, which is to import a component here. So right after this button here, and this is just a test, let's import the Logo Component. So let's save, and let's see what happens. And there it is. So here we have our logo again, but this time, do you think that it is still a Server Component as it is here? Well, down here, it is actually now not a Server Component, but a Client Component, and once again, that's because this logo right here, so this component file, doesn't have the "use client" directive. 

And so that's the reason why here, it is rendered as a Server Component here in this header. However, if we then import that here into this TextExpender Client Component and use it as a child, then, this component will also become a Client Component, again, because it is now inside or below the server-client boundary. So this component right here does have the "use client" directive, and so therefore, any component that it imports, such as Logo, will become a "use client" component instance as well. So never forget that we are just talking about instances here, right? But we just use the term components to make it a bit easier to talk. Otherwise, always saying component instance is a bit too much work. Now, I am using a guest browser window here, and that's why I don't have the React Developer Tools available right now, so here it actually tells us that we should go download them, and I'm sure that you did that earlier. And so what I want you to do now is to inspect the tree here, and then you will see that this component has actually been rendered on the client. And let's actually do that, or demonstrate that here. So I will just render something here or log it to the console. So if we just log LOGO here, then, we see that it renders or that it logs to the console once here on the server, because remember, these logs right here, they happen on the server. And so they come from all these Server Component instances. And then it also logged the LOGO here on this side. And so the logs that come here, so that appear here in the browser console, are exclusively from components that render on the client. And so these ones here are coming from that one. Now, if I click this, then, that moves here because we have some link there, but the big point here is that the same component can become a Server Component instance as it is here and a Client Component instance like here. All right, so this was just to demonstrate that part. And so let's now remove that again, and so we are finished here. All right, and then in the next lecture, we're gonna see another case in which we need yet another Client Component. Let's now use a Next.js provided hook in order to highlight the current link in the site navigation. But first of all, I actually ended up switching to another window here so that we can now see the component tree right here. And so if you analyze the tree, and maybe you already did in the previous lecture, you'll see that you have a bunch of components here, which are all provided by Next.js. So you have all these ErrorBoundaries, you have these NotFoundBoundaries. So all these are set up from our error.js files and our loading.js files and all of those. So they will create all of these boundaries here and we have a bunch of other components. But what's interesting here is that indeed, we cannot see any of the component names that we created here as server components. So nowhere here it has like a page component or maybe if we go here, right here. So here we actually have like a CabinList component, but if we scroll down here, even all the way down, we cannot see anywhere a component that is called CabinsList. And so again, that's because that has already been rendered on the server. And this component tree right here is only the client part that is indeed rendered on the client. Now, just coming back here, we can notice that indeed, we have the TextExpander component that we just created in the previous lecture. And so this, of course, is now rendered on the client. And so it shows here exactly the name of the component that we gave it. And what's also interesting here is that notice right here that this component has been rendered by hydrateRoot, meaning that this component was first rendered on the server and then it has been hydrated here on the client just as we have learned many times before in the course. So in any other app that we built before, it would only say rendered by React, something here but not hydrateRoot. So this is only for a server-side rendered application that is then hydrated on the client. Now another thing since we're already here that I wanted to quickly show you is that here, notice how we have a suspense boundary. Maybe up here another one. Well, no. And so this suspense is well, now we can see it, but anyway, we still have that suspense there. And here we can manually set that to true. And so then we will see that loading spinner again. So we can actually manipulate also, or we can play around with the suspense boundary here. Then here you have a bunch of like internal stuff and as soon as we type false, then our content is back again. All right, so that was just a small piece about the developer tools here. But moving back now, the goal of this lecture is to highlight the currently active link. So right now, we're basically here in this home, so we want this one to be highlighted. Then when we're here, we want this one to be highlighted and here the same. So let's move to that component file. And the way in which we can do that is using a React hook or actually a custom hook that Next.js provides to us. So there's no way of doing this using server-side rendering. Again, instead, Next.js provides us with a hook that will give us the current URL. And so then we can compare that with the URL of each of these links and then mark them as active correspondingly. All right. So let's call this the pathname, and we're going to use the hook called usePathname. And so since this is indeed a hook, let's see what happens when we save this. And there we go. usePathname only works in client components, and that makes sense. So it is, in the end, a React hook, even if it's a custom one. And so that means that this needs to be a client component, so use client and then we should be back. So everything works the same. And now let's just log this pathname to the console so that we see what we're actually working with here. And so indeed, we get a /account/reservations, so exactly this and here just /account. And so those basically are exactly the same as these paths right here. So what we can do is to just have some conditional styling basically. So if the current pathname is equal to the one that is in the link, then it should be highlighted. So here we have that class name. So this Tailwind string right here. And this is already a template literal. And so here we can just now do that conditional styling, like we have done many times before. So we can just say pathname, if that is equal to the current link.href, because remember, we are actually building this navigation by looping over this array right here. 

So here we just have to write all of this stuff once. So if the pathname is equal to the current links.href, which again is this right here, well, then let's give it some additional style. And if not, then no additional style. And in this case, this style is bg-primary-900, which is just slightly lighter, and beautiful. So that stays there. And the same here. And with this, our work is actually already done. So in this case, it might have seemed that we could add this functionality already on the server, but for some reason, we need to actually use a React hook, even though this doesn't seem like a very dynamic feature. So what this means is that sometimes we just need to switch to a client component only in order to be able to use a React hook. And so then just to come back to this part right here, this site navigation should show up somewhere here in our component tree. Well, not here because this contains all of this stuff, but yeah, here it is. Nice. So that works. We no longer need this one. And now it's time to move on to another client component that we're gonna need in the next lecture, which is gonna be one of the most important ones of this section and maybe even off this entire Next.js development. Now it's time to answer one big and important question. How can we share state between the client and the server? Now we already know that we can pass data from the server to the client, but how can we pass data from the client back to the server? Well, let's find out by building a filter component. And this is gonna be a full pact, but extremely important lecture for you with a lot of different new concepts. And so let's go. So let's say that we want a filter here in our cabin's overview page to allow users to filter by the cabin capacity, which is here the number of guests. So we might have a filter for small cabins like only these two with two guests. Then maybe these here are some medium ones like four and six guests, and then eight and 10 guests might be a large cabin. So a filter only rendering these two large cabins. Now, in order to implement this, we will require some kind of interactivity, or in other words, we're gonna have to implement a client component where the user can click and which will somehow register the filter that the user wants to apply. But then we get back to that big question, how do we then share the state, and in this case, the state of which filter has been applied from the client to the server component that actually renders these cabins here? And again, it is very easy to basically share state from server to client. We just need to send it or pass it as a prop. But the other way around is not so straightforward. So again, sharing some state that we register on the client to the server. Now the most obvious and easiest, and I would say best way of doing that is to store the state right in the URL. So basically what we're gonna do is as the user clicks on the filter, that will then add the filter term to the URL. And then in the server component, we can read that data from the URL and filter accordingly. All right, and let's actually start with the part on the server. So here we're going to then build a URL with a search parameter or a search query, for example, let's say capacity and set it to small. Now of course for now, nothing changes here because we're not reading this data, but this is what the URL is gonna look like, all right? And so we now have a way in Next.js of getting this data here into a page. So we can't actually get it right into any server component that we want, but we can only read it really in pages. And so here I am already on the Cabin's page, which is able to receive that data as a prop. So we already saw the params prop here in this page, but besides that, there's also the searchParams. So let's just log that to the console for now. And of course, since we're on the server, this is going to appear in this terminal right here. And so immediately we get capacity set to small, which is exactly what we have here in the URL. And so this is a great way of sharing state between the client and the server. All we need to do is to implement some way of getting the data actually to the URL and then of reading the data from the URL in the server. And so that's already what we're doing here. And again, this searchParams is only available on the page. So really only in page.js, not in server components. 

So therefore we're just gonna store that filter right here. So, the value, so let's do searchParams and then let's read the capacity from the UL like this. So at optional chaining, because of course if there's no filter at all, then this will not exist. And so then let's actually also define a fallback and let's set that to all. And so then we're gonna have small, medium, large and all. So this is what's gonna happen in this situation right here. Well, we only get here the empty capacity because we didn't log the filter. But yeah, so this will then become all because searchParams doesn't even exist. All right, but let's go back here. And so now the way in which we do this is to just pass this filter to the server component that needs the data. So just using props like we're already used to. So we accept that here. And then in this component we just filter the cabins that we get from the server accordingly. So we're actually still gonna grab all the cabins using this function here, and then only once we receive them we will filter them. So this is a bit of a waste, but no problem at all. Now, in order to do this filter, we could do some crazy turneries or something like that, but sometimes it's best to just create some variable like displayedCabins here and then assign that using some if else statements. So let's start here. Let's say filter equals all. In this case, displayedCabins will just become all the cabins, so just the cabins that we already have. All right, let's do another one. And so basically we're gonna do one for all of them since these are mutually exclusive. So then displayedCabins will become cabins.filter, .maxCapacity. And so let's say they're less or equal three. So one, two or three guests is small. And then let's just copy paste this twice. Let's do medium and large. So let's do this one here. So if the capacity is greater or equal eight, then we say it's a large cabin. And then for medium, let's say, so it needs to be between these two, so it needs to be greater than three or let's say greater equal four, it's a bit more explicit and it also needs to be cabin.maxCapacity less or equal seven. And so then here we exchange cabins with displayedCabins. And so this will then already work probably, and indeed it does. So let's just test this manually because for now of course we don't have the client side powered yet. So we don't have the filter component here, which will then allow us to set this URL directly by clicking on some buttons, now, okay? Then we have the four and six ones, then we have the large ones, then let's try all. And yeah, we have all of them. And if we have just nothing here, then that will also show all, beautiful. So the server part is largely done here. So just to recap, we just grabbed that part from the URL, like this one right here, using the searchParams prop, which every single page also gets. So just like the normal params, we also get searchParams. Now one important thing about this is that this searchParams can of course also not be known at runtime, right? What this means is that whenever we make use of the searchParams, the page can no longer be statically rendered. So right now, this cabin's overview page will now always be dynamically rendered, meaning that what we have here, so this revalidate, this now no longer takes any effect because this only applies to statically generated pages, which makes sense, right? So there's no need to revalidate a page that is dynamic anyway. But I'll just leave this here because this is in the end just a learning project anyway. So this is really relevant in case you don't use searchParams or anything else that switches the page to dynamic rendering. And so that's why we learned all of this here earlier. But now as we move on in the project, we make this page here effectively dynamic. And yeah, again, this here then doesn't apply anymore, but I will leave it there because it was useful before, all right? So the server part is done. So we are now able to read data from the URL and act accordingly. And now all we need to do is to get that data into the URL in the first place. And so that needs to happen on the client. Let's create a brand new component here. So no pre-written code this time. And we can immediately start with the use client directive 'cause we already know that we're gonna need some interactivity. And then let's use this rfc snippet that I showed you earlier to the scaffold the component. And then here we have a div, let's just add some styles here. I'm gonna add a border, a border-primary-800, and also make this a flex container 'cause now in here is where we're gonna have all of our buttons. So a button for all cabins. Let's just add some style here also before we duplicate it. 

So some petting in the X and Y direction. Then we'll also want some hover effect. So we just say hover background, and then we want the primary color of 700. All right, so let's duplicate this, here let's say one and then this mdash symbol here, three guests. And let's do this a few more times. So then four to eight guests, or maybe four to seven and eight to 12. So this is the JSX for this component. So let's go ahead and grab that here and right here, right before the list of cabins. And so here we get our filter component, give that a save and there we go. So this looks all pretty nice already. Let's just wrap this here in a div so we can add some styles there. So let's make this a flex container and justify it to the end. And also some margin to the bottom I guess makes sense. All right, so that looks a lot nicer, but of course as we click here now nothing happens. And so now it's time to add that interactivity, which was the whole reason why we made this a client component in the first place. So let's add a handler function here. Let's call this the handleFilter. And so this will then receive a filter term which we then pass in here as we click on the button. So let's do that here. So onClick and let's call handleFilter. And so this first one is for all. Of course need to close down here. And there we go. So now we're going to use exactly the same terms that we had right here in the server component. So all, small, medium, and large, right? So then those are exactly the ones that we're gonna place in the URL. So just grab this here a few more times. So this one is the small one. Then here we have the medium one, and finally the large one. So just to check this, let's see if we get already the correct term. So here we get all, small, medium, and large, beautiful. And so now all we need to do is to get this data into the URL. And that's actually a bit more complex than it might appear on the surface, but let's do it step by step. Now first of all, we're gonna use a web API that is called URLSearchParams. So this one has nothing to do with Next.js, but it's actually a web API that provides a few methods that we can use to manipulate the URL query parameters. So this is especially useful when there are many parameters in the URL because it makes it really easy to interact with all of them. So in this case, we only have one, so only the capacity, but it's still useful to learn about this method. So then this becomes kind of a recipe that you just always have to follow in the future. So we can create a variable, let's call it params, and then we use that web API by calling new URLSearchParams. Now here we now need to actually pass in those current params. So in this case, that would be exactly this. So how do we get that data here? I mean this is of course no longer a server component and neither is it a page. And so we have no way of doing this. So on the server we get this data with the searchParams, but on the server we need to do it in another way. And so, or actually on the client. So on the client, we need to do it in another way. And here the equivalent way is to use the useSearchParams hook. So another custom hook that has been provided by Next.js and make sure that it correctly imports from next/navigation. So everything here needs to come from /.navigation and not next /route or router, I believe. So there were some equivalents in the old pages router, but here in the app router, it needs to come from this package. So next/navigation, and then we can save this here into some variable. And so this is what we now pass here into this URLSearchParams API. And so now on this params that resulted from that new web API, we can do all kinds of things. We can set different parameters, we can delete them and so on. And so now what we want to do is to set the capacity to the filter term that we got, all right? But this basically only does it internally. So this essentially only builds the URL, but it doesn't navigate to it. So it doesn't change it here in the URL bar. So that's a different step. And so for that we can use the replace function, which is provided to us by the useRouter hook. So yet another custom hook and well, I told you that this was gonna be a little bit confusing. So let's call this router and useRouter again from next navigation. So here's what I was talking about earlier, there's one in next/router and one in /.navigation, but in the app router, we need to use this one, all right? And so it is basically this custom hook here, which is gonna allow us to do programmatic navigation between routes in Next.js. So remember that there was something similar also in React Router that we learned about earlier, all right? So in each of these libraries or framework, there is always a declarative way of navigating and that's using the Link component and a programmatic way, so an imperative way of navigating. And so that's the one that we'll be using here. And so that is router.replace. And now here we need to actually construct the entire URL where we want to move to. Now part of that is the params that we just built. So we can do params and .toString. 

And again, I know this is a bit confusing, but this will just become a recipe that you can always follow in the future, all right? So this then basically converts all the parameters to a string, but we're still missing basically this part of the URL. So the pathname itself. And so once again, we need to grab that from a custom hook. So this one we actually already used I believe in one of the earlier components. So that's usePathname. And so we just placed that here as well. So pathname then here is that question mark, which is also here in the URL. And then here are the parameters. Now as a second argument here, we can pass in an object with these scroll property set to false. So this one is optional and it will ensure that the page is not gonna scroll back up to the top, which makes sense in this case. All right, and with this, we are already working or we are already ready for testing if this works. So let's see what happens if we click here and I think it did work. Yeah, beautiful. The URL is updated, we get the new cabins here and this works just great. Let's just reload here and while in this case you cannot really see it, but it takes some time for the new cabins here to appear. Let me just do the artificial slowdown here. So in getting the cabins, just turn that back on. So then we can see here the the slider for a little bit or the spinner. But notice that as we click here, it still takes some time for the cabins to load, but we actually see no spinner anymore. So let's do that again. So as I click here, it will take two seconds, but in the meantime, nothing happens. While this time it was actually faster, maybe it did some preloading here. But if we just reload this again, maybe now we click here, then you see it takes two seconds until the data appears. And in the meantime we get no visual feedback that the data is being loaded in the background, which is really not ideal. So why is that? Why are we not seeing or getting a new loading spinner? And actually we did already talk about this way back and I'm sure you're not gonna remember that, but that's not problem at all as it's been a long time and there's just so much stuff to learn. But anyway, the reason that a spinner is not rendered in the meantime is that a navigation in Next.js is always wrapped in a React transition. And in a transition, the suspense will not hide the content that has already been rendered earlier. So that's just the default behavior of suspense that we're seeing here. Again, because the Next.js automatically wraps these page transitions or navigations, which in fact they are. So we're getting a new URL. And so we are indeed doing a navigation. And so in that case, since it is wrapped in a transition, suspense will not hide the already rendered content, it will just wait and swap it out as soon as the new content comes in. But luckily for us, we can actually fix this. So let's come here where the suspense actually is. And the way in which we fix that is by passing in a unique key. So I think I also mentioned that earlier, maybe even in the suspense lecture, but I actually don't remember at this point. But what matters is that here we pass in the key prop. So just like we do when we render a list of something so that each item in the list gets a unique key. So what is unique for each of these filter options here? Well, it's exactly that value that we get from the filter. So this one here, right? And so all we have to do is to pass in this here and not because the suspense needs the filter, of course this is just because the filter will be unique. And so whenever this value changes here, then the fallback will be shown again whenever the component inside is suspending. So let's check that out and it's already doing something and beautiful. So this is a lot closer to what users expect to happen when some data is actually loading. So again, sometimes it's instantaneous and that's because some caching is actually happening during development. Yeah, but this is exactly the behavior that we were looking for. So let's just deactivate this here again because it's not that slow thankfully. And with debt done, the only thing that is left to do is to also mark the current filter here as active, which I think is a pretty important feature as well. So let's just go back there. Here, the CabinList, we can already close I believe. And so now let's just first of all read the current value from the searchParams. So let's do filter, or let's call it activeFilter equals searchParams.get. So this is just the way this searchParams that we get from useSearchParams work. So we cannot just do .capacity, but we do it like this. So .getCapacity. And if that doesn't exist, then we use this knowledge coalescing operator as I think it's called to just give it a fallback. So in case we don't have anything in the URL, okay? And now we can just conditionally apply some more styles right here. However, that will actually create a lot of repetitive code. And so I think it's a good idea to abstract this button away into its own component. So let's just quickly do that, create a new component right here. So function Button, which of course will also become a client component. So it's also created inside this file which uses the use client directive. 

So let's just grab one of these buttons here and then we just pass in everything we need in order to make the button unique. So that's going to be the filter, the handleFilter prop, and then also the activeFilter. Okay, so this handleFilter is just a function that we pass in. So that's this one here. The filter will be just a search term. And to make this a bit easier to understand, let's just use this here immediately. So Button, then let's copy this part here as well. So this is gonna be the children then. And then here, let's pass in the filter. So that filter is gonna be large, so just like this. Then handleFilter, which is just the handleFilter function that we already created. Of course here we don't need any of that. And finally, the activeFilter that we also already created, all right? So this was just so we know what we actually get and how we use it. So here, this is then gonna become the children, and here we have the filter term itself. And then here, let's add that conditional styling that I mentioned earlier. So whenever in one button, the filter is equal to the activeFilter, then let's just add some more styles here. And those styles is to change the background to a primary of 700 and the text also to a much lighter color like this. And then also the other case. And yeah, now we just need to replace all of our buttons with this one. So I'm just gonna duplicate this here a bunch of times, basically redoing everything that we had done, but it's just a few minutes here. So All cabins. Then next we have small, which is two to four if I remember correctly. Next time or next one we have medium, which is four to seven. So here that's actually three. And then we have large, so that one we already had. So all, small, medium and large that looks correct. So we can get rid of these other ones. Let's just manually reload here. Well, what's happening here? Oh, we're not returning anything, so that's not ideal, and nice, beautiful. So this was a lot of work, a lot of moving parts and a lot of important new concepts. And so let's now just recap. So we were looking for sharing state between the client and the server. And in this particular case we wanted to basically have some state here regarding the number of guests that should be a filter for the cabins here. And in Next.js, the best way of sharing that state is to just place it in the URL, not only because this is the easiest way to do it, but also because it makes these pages here really nicely shareable and bookmarkable, if those are valid words. So the way we do this is that we built this component here as a client component because it needs that interactivity. And then as we click on each of these buttons, we just use the router.replace function to navigate to that new URL. And so thanks to Next.js, this will create a nice client site navigation. So there's not gonna be any full page reloads here. And so with this, we have now added our state to the URL and in particular into this searchParam of capacity. Now back on the server, we can of course get that data from the URL, and we do so right here in the page component because that page component gets access to the searchParams prop. And so that prop then contains always the data that is currently in the searchParams. Now, one thing that I actually didn't mention yet because we were just writing our code, but this is very important, is that whenever this searchParams here changes, which is a result of the URL changing, this server component here will re-render. So remember how we learned way back when we first talked about server components that a server component re-renders whenever there is a navigation. And so that's exactly the situation that we have right here. So when we click on one of these here, we have a navigation. So the URL changes. And so then this page here gets new searchParams, and as a result, so as a result of the navigation, then this server component will re-render. And so that will then of course re-render this CabinList because it's a child component. And so just like in client-side React, in server-side React, also the entire child component tree will re-render. And so then this CabinList will just re fetch the data because the whole component will run again. And so that's how this works essentially. Whenever we navigate to one of these other routes or these other URLs, the entire component run again, so the entire page and also this entire Cabins List component. And so since it runs again, it fetches the data again. And so that's why we then also see that loading spinner, right? Now, as I also mentioned already, since we're now using the searchParams, which is of course unknown at build time, the page will now need to be regenerated at runtime. So basically for each new request. So that means that the page is now no longer static but dynamic. Finally, there was just one important thing that we needed to fix here in this suspense, which was the fact that no loading spinner was rendering here. So the fallback was not shown. And once again, the reason behind that is that all page navigations are automatically wrapped in transitions in Next.js. And so in that case, and you can also read that in the suspense documentations. So in that case, suspense will not re-render the fallback. And the way we fix that is to pass in a unique key. And so then whenever the key is different and the child component here suspense, then the fallback will be shown again, okay? So this was maybe one of the most important lectures of this entire course because this is something that's pretty common. 

And so it's also nice that you get to basically then use this recipe here always in the future 'cause it's always gonna be a bit similar to what we have here. So please make sure to carefully review this entire lecture before moving on because there are just so many different moving pieces that you really need to understand and that you need to know once you become a professional Next.js developer. All right, so we had a few examples now where we needed client components in server components, and that's by far, the more common option, but we can also do it the other way around, which is rendering server components in client components. And this is a lot more counterintuitive and also a lot more advanced, but at this point we can do it. So let's go here to our guest area and then to the guest profile. So here we have this selector, which has all the countries in the world and so let's take a look at where that actually comes from. So let's open up here, account then profile and page.JS. And let's scroll a little bit here. And so here we have this select country component. So this select country is already in our components folder. And so this is how it works. So it's an async function which calls this get countries function here, which in itself does a fetch request to this URL right here. So basically a very simple function that simply gets all the country's data from the country's API that we actually used in this course earlier, or maybe in my JavaScript course. So many courses, I don't even remember the projects anymore. But what matters here is that it gets these countries, it also gets these flags here, which we're gonna take a look at later. So it builds these flags, and then it just creates this select element which then contains again, all of these different countries. So that's where they come from. So this, of course, needs to be a server component. So the select country and right now, that's no problem at all because of course, this page, so this guest profile page is also a server component. But now let's say that for some reason this form here needs some state, and actually a bit later in the course, that will actually be the case. And so what we're gonna do now is to take this form and place it into a client component. So this entire form, let's cut that from here and let's create a new component called "update profile form.JS". And again, the RFC snippet, let's paste that here. Then of course here, we need to import that component from here, and we can then also remove that import in this page. And also these need to move over, as well, like this. And yeah, let's say now we need, again, some state here, let's say a count and set count, and we're gonna change this again later, I guess in the next, or in one of the next sections. And all right and so if we want to use state here, of course, this needs to become a client component, so use client, but now maybe you start to see the problem. We have a client component that here tries to import and then render this server component. And as we learned in the first lecture of this section, this is not gonna work like this. This is gonna create some problems, but let's check it out. So let's first try it and then afterwards try to solve it. So update profile form, let's just import it here, and see what happens and there we go. Something went wrong. Maybe here we get a bit more information. So just superbase is required. So this is not really helpful. Let's see another one here. So that's basically the same. And so the reason for this is that now our code is attempting to run the create client on the client. So on the browser, and there, of course, this environment variable here is not available. So it is trying to run this on the client indeed, because we are now importing a client component or actually a server component. So again, we're in this client component right here, which is attempting to import and also use a server component. And it needs to be a server component because it is fetching some data. I mean, it is not explicitly a server component. So we have no use server like this. I mean, we actually do, but that's for server actions, not for server components. So more about that later. But we didn't tell React that this here is a server component. So if we weren't fetching any data here, then we could actually render that component right here. But we do need to fetch this data because we don't want to change the component. So we don't want to get this fetching of the data out of here. So let's imagine as it says here, that our colleague built this component on our team. And so we should not change this component right here. And since it has data fetching, and it is even an async await function, this means that it needs to run on the server and not on the client. But right now, of course, since it is below the server client boundary, by default, it will just become now a client component. So how do we fix this? Well, remember from the first lecture of this section that the only way in which we can render a server component in a client component is by passing it as a prop. And so let's do that. So we'll just grab this from here, remove the import because this is the one that's causing the problem. And so let's then pass it here as a prop, and let's actually pass it as a children prop. So like this. Okay? Then let's import it here in the server component. And so this is why this is going to work now because we're now importing a server component inside another server component. And so this component will then run here. So it will already create the component instance, and only that instance, this already executed component basically is then being passed into the client component, which is this one. And that's no problem at all.

 Again, because all the work in here has already happened. So the data fetching has happened on the server, all the JSX has run and so basically this just becomes a React element and so then that React element is what's gonna be passed into the client component. And that again, is no problem at all. That works just fine. All right and now here all we need to do, well, where was it now actually? I guess it was here. And so here all we have to do, well, actually not like this. It needs to be lowercase, and we need to accept that here and also remove it from the wrong import, give it a save, and then let's see the magic happening. And now the nationality is not defined. So let's see. Okay, we have some default country here, so we're gonna fix all this once we actually build the form and actually have the correct guest logged in. And so for now, let's just also copy this here. So again, we're gonna fix all of this later. The point here was just to show you this other way around, so the opposite of what we had been doing earlier. So again, this time what we're doing is essentially passing a server component, which is this one, into a client component, which is this one. And again, we're doing this now by passing it as a prop. This is the only way in which this is allowed. And if we reload this now, then beautiful, this will now work just fine. And if we inspect our component tree, then we should see this component right here in the end. But that select country component is nowhere to be seen. Again, because it is not a client component. All we did was render it on the server and then once it was already rendered, so once the countries had been fetched and the React elements had been generated, only then we passed it into the client component. And here we can actually see that. So here are these children, even though we cannot see all of it, right? But basically this symbol, this stuff right here, this can tell us already that this is some React element that had been passed in. Now all right? So if this was confusing to you, then please make sure to review that first theory lecture of this section and also analyze exactly again what we did here. So as I mentioned in the beginning, this is not something that is very, very common, but it is important that you know about this technique and also that you understand it because really understanding this is what will make you a great next JS developer. All right, so let's close all of this up. We're gonna come back to this later, but now in the next lecture, let's actually come back to these individual cabin pages right here and start working on the reservation part.

